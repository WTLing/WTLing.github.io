<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>剧本</title>
    <link href="/2021/12/23/%E5%89%A7%E6%9C%AC/"/>
    <url>/2021/12/23/%E5%89%A7%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="剧本写作"><a href="#剧本写作" class="headerlink" title="剧本写作"></a>剧本写作</h3><ol><li><p>片名</p></li><li><p>主题</p></li></ol><p>​    （5-15个词）</p><ol start="3"><li><p>故事简介</p></li><li><p>故事梗概</p></li><li><p>剧本大纲</p></li><li><p>塑造角色</p></li></ol><h3 id="创作角色"><a href="#创作角色" class="headerlink" title="创作角色"></a>创作角色</h3><p>描述角色的：</p><table><thead><tr><th>兴趣爱好</th><th>加教育背景</th><th>爱情生活失败与否</th><th>生活目标</th><th>家庭生活</th></tr></thead><tbody><tr><td>身体姿态</td><td>与父母和兄弟姐妹的关系</td><td>音乐品味</td><td>经济状况</td><td>饮食习惯</td></tr><tr><td>政治观点</td><td>旅行习惯</td><td>最喜欢的度假地点</td><td>最坏的习惯</td><td>最怕的事情</td></tr><tr><td>最喜欢的场景</td><td>对犯罪行为的反应</td><td>看电视的习惯</td><td>酒醉后的行为</td><td>外号</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter 插件</title>
    <link href="/2021/12/03/Jupyter-%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/12/03/Jupyter-%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">pip install --upgrade jupyter<br>pip install jupyter_contrib_nbextensions <br>jupyter contrib nbextension install --user<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pip源</title>
    <link href="/2021/12/02/pip%E6%BA%90/"/>
    <url>/2021/12/02/pip%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>pip install scrapy -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>pip国内的一些镜像</p><p>  阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>  中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>  豆瓣(douban) <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>  清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>  中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>量化交易</title>
    <link href="/2021/12/02/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    <url>/2021/12/02/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/</url>
    
    <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>交易系统<ul><li>数据获取<ul><li>通过类似期货CTP接口的模式获取</li><li>通过券商获取tick数据</li><li>爬虫获取</li></ul></li><li>数据处理</li><li>算法</li><li>下单<ul><li>券商交易接口</li></ul></li><li>其他<ul><li>回测</li><li>优化</li></ul></li></ul></li></ul><hr><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>趋势性交易（金融专业出生，对财务、金融市场非常了解）<ul><li>期货CTA</li></ul></li><li>市场中性（计算机专业出生，编程、机器学习技术、数据挖掘）<ul><li><strong>Alpha策略</strong><ul><li>对冲</li><li><strong>量化选股、择时</strong></li></ul></li><li>统计套利</li></ul></li><li>高频交易（擅长算法编程，c/c++做交易）<ul><li>程序化交易</li></ul></li></ul><h3 id="金融产品的投资策略"><a href="#金融产品的投资策略" class="headerlink" title="金融产品的投资策略"></a>金融产品的投资策略</h3><ul><li>股票：市场中性策略占大多数、设计少数的趋势性交易</li><li>期货：趋势性交易占大多数</li></ul><h3 id="量化交易的优势"><a href="#量化交易的优势" class="headerlink" title="量化交易的优势"></a>量化交易的优势</h3><ul><li>严格的纪律性：人的缺点</li><li>完备的系统性：多层次、多角度、多数据</li><li>靠数学模型取胜</li></ul><hr><p><a href="www.ricequant.com">策略网站RiceQuant</a></p><h3 id="一个完整策略需要做的事情"><a href="#一个完整策略需要做的事情" class="headerlink" title="一个完整策略需要做的事情"></a>一个完整策略需要做的事情</h3><ul><li>选择策略的运行信息<ul><li>选择运行区间（5-10年历史数据）和初始资金</li><li>选择回测频率（<strong>每日交易判断</strong>/每分钟交易判断）</li><li>选择股票池</li></ul></li><li>编写策略的逻辑<ul><li>获取股票行情、基本面数据</li><li>选择哪些股票以及交易时间</li></ul></li><li>分析结果<ul><li>策略指标分析</li></ul></li></ul><h3 id="策略运行流程"><a href="#策略运行流程" class="headerlink" title="策略运行流程"></a>策略运行流程</h3><ul><li>init：在运行策略时首先被运行，只运行一次</li><li>before_trading：每天都会调用，在handle_之前运行</li><li>handle_bar：每天都会调用</li><li>都有一个context对象，用于函数之间进行传递</li></ul><h3 id="数据获取API和交易API"><a href="#数据获取API和交易API" class="headerlink" title="数据获取API和交易API"></a>数据获取API和交易API</h3><h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><ul><li>获取指定行业、股票列表</li><li>handle_bar-指定股票行情历史数据</li><li>get_fundamentals-查询财务数据：基本面数据，公司的数据</li></ul><h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在线工具集</title>
    <link href="/2021/12/02/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <url>/2021/12/02/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="在线画图工具"><a href="#在线画图工具" class="headerlink" title="在线画图工具"></a>在线画图工具</h2><p><a href="https://www.processon.com/">在线画图ProcessOn</a></p><p><a href="https://app.diagrams.net/">在线画图Diagrams</a></p><p><a href="http://www.mindline.cn/webapp">在线思维导图工具</a></p><p><a href="https://www.uupoop.com/">在线PS</a></p><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><p><a href="https://www.ip138.com/">IP地址归属地查询</a></p><p><a href="https://www.ipip.net/ip.html">IP地址归属地查询</a></p><p><a href="https://www.fly63.com/php/http/">HTTP接口测试工具</a></p><h2 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h2><p><a href="https://cn.office-converter.com/">在线多媒体转换</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Stock_v1 Valid</title>
    <link href="/2021/11/26/Stock-v1-Valid/"/>
    <url>/2021/11/26/Stock-v1-Valid/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">## 说明</span><br><span class="hljs-type">Type</span>: <span class="hljs-number">0</span> 普通<br>  <span class="hljs-number">1</span> 只满足五日均线<br>      <span class="hljs-number">2</span> 只满足多次金叉<br>      <span class="hljs-number">3</span> 同时满足<br>      <br>How to buy: <span class="hljs-number">0</span> <span class="hljs-number">10</span>,<span class="hljs-number">000</span><br>   <span class="hljs-number">1</span> <span class="hljs-number">50</span>,<span class="hljs-number">000</span><br>    <span class="hljs-number">2</span> <span class="hljs-number">200</span>,<span class="hljs-number">000</span><br>      <span class="hljs-number">3</span> <span class="hljs-number">300</span>,<span class="hljs-number">000</span><br> <span class="hljs-comment"># 按照优先级从高到低买，买完全部的钱</span><br></code></pre></div></td></tr></table></figure><h3 id="2021-11-25-Fri"><a href="#2021-11-25-Fri" class="headerlink" title="2021.11.25 Fri"></a>2021.11.25 Fri</h3><p><a href="2021-11-25.txt">2021-11-25数据</a></p><table><thead><tr><th>Stock Code</th><th>Type</th><th>Close Price</th><th>Num</th><th>Buy Market Value</th><th>Sale Price</th><th>Sale Market Value</th><th>Profit</th><th>Profit Rate</th></tr></thead><tbody><tr><td><a href="http://quote.eastmoney.com/000568.html">000568</a></td><td>1</td><td>234.94</td><td>212</td><td>50,000</td><td>233.68</td><td>49,540.16</td><td>-459.84</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/000719.html">000719</a></td><td>3</td><td>7.66</td><td>39,164</td><td>300,000</td><td>7.38</td><td>289,030.32</td><td>-10,969.68</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/000818.html">000818</a></td><td>1</td><td>37.4</td><td>1,336</td><td>50,000</td><td>40.10</td><td>53,573.6</td><td>+3,573.6</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/300014.html">300014</a></td><td>1</td><td>145.11</td><td>344</td><td>50,000</td><td>148.75</td><td>51,170</td><td>+1,170</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/300124.html">300124</a></td><td>1</td><td>69.37</td><td>720</td><td>50,000</td><td>67.37</td><td>48,506.4</td><td>-1,493.6</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/300223.html">300223</a></td><td>1</td><td>147.81</td><td>338</td><td>50,000</td><td>137.97</td><td>46,633.86</td><td>-3,366.14</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/300244.html">300244</a></td><td>1</td><td>34.7</td><td>1,440</td><td>50,000</td><td>33.61</td><td>48,398.4</td><td>-1,601.6</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/300379.html">300379</a></td><td>1</td><td>33.98</td><td>1,471</td><td>50,000</td><td>33.74</td><td>49,631.54</td><td>-368.46</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/600875.html">600875</a></td><td>1</td><td>20.12</td><td>2,485</td><td>50,000</td><td>20.20</td><td>50,197</td><td>+197</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/603139.html">603139</a></td><td>1</td><td>19.57</td><td>2,554</td><td>50,000</td><td>19.59</td><td>50,032.86</td><td>+32.86</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/603267.html">603267</a></td><td>1</td><td>179.91</td><td>277</td><td>50,000</td><td>175.06</td><td>48,491.62</td><td>-1,508.38</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/603358.html">603358</a></td><td>1</td><td>23.3</td><td>2,145</td><td>50,000</td><td>22.30</td><td>47,833.5</td><td>-2,166.5</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/603599.html">603599</a></td><td>1</td><td>38.99</td><td>1,282</td><td>50,000</td><td>39.71</td><td>50,908.22</td><td>+,908.22</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/603630.html">603630</a></td><td>1</td><td>22.55</td><td>2,217</td><td>50,000</td><td>22.82</td><td>50,591.94</td><td>+591.94</td><td></td></tr><tr><td><a href="http://quote.eastmoney.com/603738.html">603738</a></td><td>1</td><td>63.2</td><td>791</td><td>50,000</td><td>61.80</td><td>48,883.8</td><td>-1,116.2</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>1,000,000</td><td></td><td>983423.22</td><td>-16576.78</td><td></td></tr></tbody></table><p><strong>Sum</strong>：1,000,000</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter配置</title>
    <link href="/2021/11/25/Jupyter%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/11/25/Jupyter%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">jupyter notebook --genetate-config<br></code></pre></div></td></tr></table></figure><h3 id="配置文件地址"><a href="#配置文件地址" class="headerlink" title="配置文件地址"></a>配置文件地址</h3><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">~<span class="hljs-regexp">/.jupyter/</span>jupyter_notebook_config.py<br></code></pre></div></td></tr></table></figure><h3 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> notebook.auth <span class="hljs-keyword">import</span> passwd<br>passwd()<br><span class="hljs-comment"># 此时需要输入两次密码（一次设置，一次确认），然后生成sha1的密文，拷贝下来。</span><br><span class="hljs-comment"># Enter password: ········</span><br><span class="hljs-comment"># Verify password: ········</span><br><span class="hljs-comment"># sha1:b11ba7ae862e:6eeb922ef6b770e43a1c90922ba341faaaaaaaa</span><br><br></code></pre></div></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">c.NotebookApp.ip=<span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment"># 允许所有ip访问</span><br>c.NotebookApp.password = <span class="hljs-string">u&#x27;sha1:...刚才复制的那个密文&#x27;</span><br>c.NotebookApp.open_browser = <span class="hljs-literal">False</span> <span class="hljs-comment"># 是否打开浏览器</span><br>c.NotebookApp.port = <span class="hljs-number">8888</span> <span class="hljs-comment">#指定端口</span><br></code></pre></div></td></tr></table></figure><h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">ssh -L <span class="hljs-number">7777</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7777</span> <span class="hljs-selector-attr">[userName]</span>@<span class="hljs-selector-attr">[ip]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[port]</span><br><span class="hljs-number">7777</span>对应配置文件里面的指定端口<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Stock_v1</title>
    <link href="/2021/11/23/Stock-v1/"/>
    <url>/2021/11/23/Stock-v1/</url>
    
    <content type="html"><![CDATA[<h2 id="如何计算MACD指标"><a href="#如何计算MACD指标" class="headerlink" title="如何计算MACD指标"></a>如何计算MACD指标</h2><h3 id="计算EMA"><a href="#计算EMA" class="headerlink" title="计算EMA"></a>计算EMA</h3><p>$$<br>E M A_{12}(n)=\frac{11}{13} * E M A_{12}(n-1)+\frac{2}{13} * \operatorname{Price}(n)<br>$$</p><p>$$<br>E M A_{26}(n)=\frac{25}{27} * E M A_{26}(n-1)+\frac{2}{27} * \operatorname{Price}(n)<br>$$</p><h3 id="计算DIFF"><a href="#计算DIFF" class="headerlink" title="计算DIFF"></a>计算DIFF</h3><p>$$<br>D I F(n)=E M A_{12}(n)-E M A_{26}(n)<br>$$</p><h3 id="计算DEA"><a href="#计算DEA" class="headerlink" title="计算DEA"></a>计算DEA</h3><p>$$<br>D E A(n)=D E A(n-1) * \frac{8}{10}+D I F(n) * \frac{2}{10}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_EMA</span>(<span class="hljs-params">history_data</span>):</span><br>    EMA_26 = [<span class="hljs-number">0</span>]<br>    EMA_12 = [<span class="hljs-number">0</span>]<br>    sz = <span class="hljs-built_in">len</span>(history_data)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sz):<br>        EMA_12.append(EMA_12[-<span class="hljs-number">1</span>] * <span class="hljs-number">11</span>/<span class="hljs-number">13</span> + <span class="hljs-number">2</span>/<span class="hljs-number">13</span> * history_data[i])<br>        EMA_26.append(EMA_26[-<span class="hljs-number">1</span>] * <span class="hljs-number">25</span>/<span class="hljs-number">27</span> + <span class="hljs-number">2</span>/<span class="hljs-number">27</span> * history_data[i])<br>    <span class="hljs-keyword">return</span> EMA_12[<span class="hljs-number">1</span>:], EMA_26[<span class="hljs-number">1</span>:]<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_DIFF</span>(<span class="hljs-params">EMA_12, EMA_26</span>):</span><br>    DIFF = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(EMA_12)):<br>        DIFF.append(EMA_12[i] - EMA_26[i])<br>    <span class="hljs-keyword">return</span> DIFF<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_DEA</span>(<span class="hljs-params">DIFF</span>):</span><br>    DEA = [<span class="hljs-number">0</span>]<br>    sz = <span class="hljs-built_in">len</span>(DIFF)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sz):<br>        DEA.append(DEA[-<span class="hljs-number">1</span>] * <span class="hljs-number">8</span> / <span class="hljs-number">10</span> + DIFF[i] * <span class="hljs-number">2</span> / <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">return</span> DEA[<span class="hljs-number">1</span>:]<br></code></pre></div></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tushare <span class="hljs-keyword">as</span> ts<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> baostock <span class="hljs-keyword">as</span> bs<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">#写入tyshare API token</span><br>pro = ts.pro_api(token=<span class="hljs-string">&#x27;XXX&#x27;</span>)<br>lg = bs.login()<br><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;abc.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br>start = time.time()<br><br><span class="hljs-comment"># 计算指标</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_EMA</span>(<span class="hljs-params">history_data</span>):</span><br>    EMA_26 = [<span class="hljs-number">0</span>]<br>    EMA_12 = [<span class="hljs-number">0</span>]<br>    sz = <span class="hljs-built_in">len</span>(history_data)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sz):<br>        EMA_12.append(EMA_12[-<span class="hljs-number">1</span>] * <span class="hljs-number">11</span>/<span class="hljs-number">13</span> + <span class="hljs-number">2</span>/<span class="hljs-number">13</span> * history_data[i])<br>        EMA_26.append(EMA_26[-<span class="hljs-number">1</span>] * <span class="hljs-number">25</span>/<span class="hljs-number">27</span> + <span class="hljs-number">2</span>/<span class="hljs-number">27</span> * history_data[i])<br>    <span class="hljs-keyword">return</span> EMA_12[<span class="hljs-number">1</span>:], EMA_26[<span class="hljs-number">1</span>:]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_DIFF</span>(<span class="hljs-params">EMA_12, EMA_26</span>):</span><br>    DIFF = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(EMA_12)):<br>        DIFF.append(EMA_12[i] - EMA_26[i])<br>    <span class="hljs-keyword">return</span> DIFF<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_DEA</span>(<span class="hljs-params">DIFF</span>):</span><br>    DEA = [<span class="hljs-number">0</span>]<br>    sz = <span class="hljs-built_in">len</span>(DIFF)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sz):<br>        DEA.append(DEA[-<span class="hljs-number">1</span>] * <span class="hljs-number">8</span> / <span class="hljs-number">10</span> + DIFF[i] * <span class="hljs-number">2</span> / <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">return</span> DEA[<span class="hljs-number">1</span>:]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_DIFF_DEA</span>(<span class="hljs-params">history_data</span>):</span><br>    EMA_12, EMA_26 = Get_EMA(history_data)<br>    DIFF = Get_DIFF(EMA_12,EMA_26)<br>    DEA = Get_DEA(DIFF)<br>    <span class="hljs-keyword">return</span> DIFF, DEA<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_Turn</span>(<span class="hljs-params">stock_code</span>):</span><br>    <br>    <span class="hljs-comment"># 获得股票换手率</span><br>    rs = bs.query_history_k_data_plus(stock_code,<br>                                      <span class="hljs-string">&quot;turn&quot;</span>,<br>                                      start_date=<span class="hljs-string">&#x27;&#x27;</span>, end_date=<span class="hljs-string">&#x27;&#x27;</span>,<br>                                      frequency=<span class="hljs-string">&quot;d&quot;</span>, adjustflag=<span class="hljs-string">&quot;3&quot;</span>)<br><br>    data_list = []<br>    <span class="hljs-keyword">while</span> (rs.error_code == <span class="hljs-string">&#x27;0&#x27;</span>) &amp; rs.<span class="hljs-built_in">next</span>():<br>        <span class="hljs-comment"># 获取一条记录，将记录合并在一起</span><br>        data_list.append(rs.get_row_data())<br>    result = pd.DataFrame(data_list, columns=rs.fields)<br>    result = result[<span class="hljs-string">&#x27;turn&#x27;</span>]<br>    result = np.array(result)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(result[-<span class="hljs-number">1</span>])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Judge</span>(<span class="hljs-params">stock_code, Diff, Dea, stock_close, stock_mean_5</span>):</span><br>    <br>    <span class="hljs-comment"># 判断股票是否复合</span><br>    <br>    <span class="hljs-comment"># 取最后n天的数据</span><br>    n = <span class="hljs-number">50</span><br>    <br>    <span class="hljs-comment"># n 天以内的所有Diff Dea都要在0轴以上</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">if</span> Diff[-<span class="hljs-number">1</span>-i] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> Dea [-<span class="hljs-number">1</span> - i] &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <br>    distance = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        distance.append(Diff[-<span class="hljs-number">1</span> * n + i] - Dea[-<span class="hljs-number">1</span> * n + i])<br>        <br>    flag = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(distance)):<br>        <span class="hljs-keyword">if</span> distance[i] &gt; <span class="hljs-number">0</span> :<br>            flag.append(<span class="hljs-string">&#x27;+&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            flag.append(<span class="hljs-string">&#x27;-&#x27;</span>)<br>    <br>    i = <span class="hljs-number">0</span><br>    cnt_posi = <span class="hljs-number">0</span><br>    cnt_neg = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">if</span> flag[-<span class="hljs-number">1</span> * <span class="hljs-number">5</span> + i] == <span class="hljs-string">&#x27;+&#x27;</span>:  <br>            cnt_posi += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> flag[-<span class="hljs-number">1</span> * <span class="hljs-number">5</span> + i] == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> flag[-<span class="hljs-number">1</span> * <span class="hljs-number">5</span> + i] == <span class="hljs-string">&#x27;-&#x27;</span>:  <br>            cnt_neg += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> flag[-<span class="hljs-number">1</span> * <span class="hljs-number">5</span> + i] == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-keyword">if</span> cnt_posi == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> cnt_neg == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> flag[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span>:<br>        i = <span class="hljs-number">1</span><br>        max_dis = distance[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">while</span> flag[-<span class="hljs-number">1</span> - i] == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">and</span> i &lt; <span class="hljs-number">5</span>:<br>            <span class="hljs-keyword">if</span> distance[-<span class="hljs-number">1</span> - i] &gt; max_dis:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <br>        turn = Get_Turn(stock_code)<br>        <span class="hljs-keyword">if</span> turn &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> turn &gt; <span class="hljs-number">5</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 初步满足条件</span><br>        <br>        <span class="hljs-comment">## 满足有多次0上金叉</span><br>        <span class="hljs-comment"># n 天以内的所有Diff Dea都要在0轴以上</span><br>        flag_1 = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> Diff[-<span class="hljs-number">1</span>-i] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> Dea [-<span class="hljs-number">1</span> - i] &lt; <span class="hljs-number">0</span>:<br>                flag_1 = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> flag_1:<br>            i_ = <span class="hljs-number">0</span><br>            cnt_posi_ = <span class="hljs-number">0</span><br>            cnt_neg_ = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> i_ &lt; n:<br>                <span class="hljs-keyword">if</span> flag[-<span class="hljs-number">1</span> * n + i_] == <span class="hljs-string">&#x27;+&#x27;</span>:  <br>                    cnt_posi_ += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> i_ &lt; n <span class="hljs-keyword">and</span> flag[-<span class="hljs-number">1</span> * n + i_] == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        i_ += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> flag[-<span class="hljs-number">1</span> * n + i_] == <span class="hljs-string">&#x27;-&#x27;</span>:  <br>                    cnt_neg_ += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> i_ &lt; n <span class="hljs-keyword">and</span> flag[-<span class="hljs-number">1</span> * n + i_] == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        i_ += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> cnt_neg_ == <span class="hljs-number">1</span> :<br>                flag_1 = <span class="hljs-literal">False</span><br><br>        <br>        <span class="hljs-comment">## 满足大于 五日 均线</span><br>        flag_2 = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> stock_close &lt; stock_mean_5:<br>            flag_2 = <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-keyword">if</span> flag_1 <span class="hljs-keyword">and</span> flag_2 :<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span><br>        <span class="hljs-keyword">elif</span> flag_1:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>        <span class="hljs-keyword">elif</span> flag_2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_Stock_Codes</span>():</span><br>    <br>    <span class="hljs-comment"># 获取设置板块股票代码</span><br>    data = pro.stock_basic(list_status=<span class="hljs-string">&#x27;L&#x27;</span>)<br><br>    need_market = [<span class="hljs-string">&#x27;主板&#x27;</span>, <span class="hljs-string">&#x27;创业板&#x27;</span>]<br>    data = data[data[<span class="hljs-string">&#x27;market&#x27;</span>].isin(need_market)]<br>    data = data[<span class="hljs-string">&#x27;ts_code&#x27;</span>]<br>    data = <span class="hljs-built_in">list</span>(data)<br><br>    <span class="hljs-keyword">return</span> data<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Contact_Stock_Codes</span>(<span class="hljs-params">stock_codes</span>):</span><br>    result = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(stock_codes)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            result += stock_codes[i]<br>        <span class="hljs-keyword">else</span>:<br>            result += <span class="hljs-string">&#x27;,&#x27;</span> + stock_codes[i]<br><br>    <span class="hljs-keyword">return</span> result<br><br><br>stock_codes = Get_Stock_Codes()<br>Accuracy = <span class="hljs-number">200</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Main</span>(<span class="hljs-params">batch_size=<span class="hljs-number">20</span></span>):</span><br>    suit_stocks = []<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***** 开始 ******&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(stock_codes) / batch_size)),ncols=<span class="hljs-number">6</span> ):<br>        test_string = Contact_Stock_Codes(stock_codes[batch_size * i:batch_size * i + batch_size])<br>        <span class="hljs-keyword">try</span>:<br>            df = pro.daily(ts_code=test_string, start_data=<span class="hljs-string">&#x27;20200201&#x27;</span>, end_data=<span class="hljs-string">&#x27;20210902&#x27;</span>)<br>    <br>            <span class="hljs-keyword">for</span> stock_code <span class="hljs-keyword">in</span> stock_codes[batch_size * i:batch_size * i + batch_size]:<br>                <span class="hljs-keyword">try</span>:<br>                    stock_data = df[df[<span class="hljs-string">&#x27;ts_code&#x27;</span>] == stock_code]<br>                    <br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(stock_data[<span class="hljs-string">&#x27;close&#x27;</span>])) &lt; Accuracy:<br>                        <span class="hljs-keyword">continue</span><br>                    stock_data = <span class="hljs-built_in">list</span>(stock_data[<span class="hljs-string">&#x27;close&#x27;</span>])[:Accuracy]<br><br>                    stock_close = <span class="hljs-built_in">list</span>(df[<span class="hljs-string">&#x27;close&#x27;</span>])[<span class="hljs-number">0</span>]<br>                    stock_data = stock_data[::-<span class="hljs-number">1</span>]<br>                    DIFF, DEA = Get_DIFF_DEA(stock_data)<br>                    stock_mean_5 = np.mean(stock_data[-<span class="hljs-number">5</span>:])<br>                    <br>                    <br>                    judge_result = Judge(stock_code, DIFF, DEA, stock_close, stock_mean_5)<br>                    <span class="hljs-keyword">if</span> judge_result == <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">pass</span><br>                    <span class="hljs-keyword">elif</span> judge_result == <span class="hljs-number">1</span>:<br>                        <span class="hljs-built_in">print</span>(stock_code)<br>                        file.write(stock_code + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>                        suit_stocks.append(stock_code)<br>                    <span class="hljs-keyword">elif</span> judge_result == <span class="hljs-number">2</span>:<br>                        <span class="hljs-built_in">print</span>(stock_code, <span class="hljs-string">&quot; 大于5日均线&quot;</span>)<br>                        file.write(stock_code + <span class="hljs-string">&#x27; 大于5日均线\n&#x27;</span>)<br>                        suit_stocks.append(stock_code)<br>                    <span class="hljs-keyword">elif</span> judge_result == <span class="hljs-number">3</span>:<br>                        <span class="hljs-built_in">print</span>(stock_code, <span class="hljs-string">&quot; 50天内多次金叉&quot;</span>)<br>                        file.write(stock_code + <span class="hljs-string">&#x27; 50天内多次金叉\n&#x27;</span>)<br>                        suit_stocks.append(stock_code)<br>                    <span class="hljs-keyword">elif</span> judge_result == <span class="hljs-number">4</span>:<br>                        <span class="hljs-built_in">print</span>(stock_code, <span class="hljs-string">&quot; 同时满足&quot;</span>)<br>                        file.write(stock_code + <span class="hljs-string">&#x27; 同时满足\n&#x27;</span>)<br>                        suit_stocks.append(stock_code)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">pass</span><br><span class="hljs-comment">#                         print(stock_code, &quot;换手率&quot; + str(judge_result) + &quot;%&quot;)</span><br>                <span class="hljs-keyword">except</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Wrong&quot;</span>)<br>                    <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Wrong&quot;</span>)<br>            <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">return</span> suit_stocks<br><br>suit_stocks = Main()<br>bs.logout()<br>file.close()<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(end - start))<br></code></pre></div></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2021/11/23/Stock-v1/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>小项目们</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>达芬奇</title>
    <link href="/2021/11/22/%E8%BE%BE%E8%8A%AC%E5%A5%87/"/>
    <url>/2021/11/22/%E8%BE%BE%E8%8A%AC%E5%A5%87/</url>
    
    <content type="html"><![CDATA[<h3 id="剪辑画板"><a href="#剪辑画板" class="headerlink" title="剪辑画板"></a>剪辑画板</h3><ul><li>项目设置视频帧率</li><li>先导入所有的素材，然后将素材分门别类拖入，媒体池</li><li>自己创建新时间线，命好名，干净整洁</li><li>剪辑模式<ol><li>A选择模式</li><li>T—-修建编辑模式，拖动前面片段后面片段也会跟着动</li><li>B—切刀</li></ol></li><li>素材导入模式<ol><li>插入模式：素材插入到播放头位置，如果从中间切开，后面的素材会往后移</li><li>覆盖模式：覆盖某一段</li><li>替换模式：直接替换某个素材</li></ol></li><li>音视频链接按钮可以分开/绑定音视频</li><li><strong>点击片段按F可以找到素材出处</strong></li><li><strong>标记按钮</strong>：<ol><li>旗标G：标记的是整段源素材</li><li>标记M：标记时间线上某个片段</li></ol></li></ul><h3 id="添加效果和关键帧"><a href="#添加效果和关键帧" class="headerlink" title="添加效果和关键帧"></a>添加效果和关键帧</h3><p><img src="/2021/11/22/%E8%BE%BE%E8%8A%AC%E5%A5%87/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>剪辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工具们</title>
    <link href="/2021/11/17/%E5%B7%A5%E5%85%B7%E4%BB%AC/"/>
    <url>/2021/11/17/%E5%B7%A5%E5%85%B7%E4%BB%AC/</url>
    
    <content type="html"><![CDATA[<p><strong>下载工具</strong>:<a href="https://www.motrix.app/zh-CN/">https://www.motrix.app/zh-CN/</a></p><p>磁力链聚合搜索:<a href="https://github.com/xiandanin/magnetW">https://github.com/xiandanin/magnetW</a></p><p><strong>视频素材管理工具</strong>：<a href="https://www.ysjf.com/gate">https://www.ysjf.com/gate</a></p><p><strong>数学公式ORC识别 Mathpix Snip</strong>：<a href="https://mathpix.com/">https://mathpix.com</a></p><p>文献阅读滑词翻译：<a href="https://copytranslator.github.io/guide/">https://copytranslator.github.io/guide/</a></p><p>优质课程：<a href="https://docs.qq.com/sheet/DRU5MWHZCTHFGQnhM">https://docs.qq.com/sheet/DRU5MWHZCTHFGQnhM</a></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">brew install copytranslator<br></code></pre></div></td></tr></table></figure><p><strong>安装brew</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">/bin/zsh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>安装node</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">brew install node<br></code></pre></div></td></tr></table></figure><p><strong>安装Hexo</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo<br></code></pre></div></td></tr></table></figure><p>初始化hexo目录</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> blog<br>hexo init<br></code></pre></div></td></tr></table></figure><p>显示数学公式</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-filter-mathjax<br>hexo clean<br></code></pre></div></td></tr></table></figure><p>显示图片</p><blockquote><p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p></blockquote><p>Npx搭建静态服务器局域网传数据</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 指定文件夹下<br>npx http-server<br></code></pre></div></td></tr></table></figure><p>打开弹出的网址后，找到指定文件下载就好</p><img src="/2021/11/17/%E5%B7%A5%E5%85%B7%E4%BB%AC/1.png" style="zoom:50%;"><p><strong>MAC添加全局变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /etc/paths <br><span class="hljs-built_in">source</span> ~/.bash_profile 生效<br></code></pre></div></td></tr></table></figure><p><strong>远距离传文件</strong></p><p><a href="https://www.wenshushu.cn/">https://www.wenshushu.cn/</a></p><p>阿里网盘</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch Tips</title>
    <link href="/2021/11/12/Pytorch-Tips/"/>
    <url>/2021/11/12/Pytorch-Tips/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">### 使用itertools.chain</span><br><br><span class="hljs-keyword">import</span> itertools<br><br>optim.Adam(itertools.chain(encoder.parameters(), decoder.parameters()), lr = <span class="hljs-number">1e-3</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开会心得</title>
    <link href="/2021/11/05/%E5%BC%80%E4%BC%9A%E5%BF%83%E5%BE%97/"/>
    <url>/2021/11/05/%E5%BC%80%E4%BC%9A%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="2021-11-3-8-00-PM"><a href="#2021-11-3-8-00-PM" class="headerlink" title="2021.11.3 8:00 PM"></a>2021.11.3 8:00 PM</h3><ul><li>交替Train ANIL BOIL，每次train到收敛再切换</li><li>固定Head和后几层Conv，强迫Adaptation的改变提前</li></ul><h3 id="2021-11-5-10-00-AM"><a href="#2021-11-5-10-00-AM" class="headerlink" title="2021.11.5 10:00 AM"></a>2021.11.5 10:00 AM</h3><ul><li>把300Epoch的BOIL拿来接着TrainANIL</li><li>BOIL收敛之后，再Train时，在Out loop里面把Body的lr变小，Head变大</li><li>把Adaption前后无变化的作为死记硬背</li><li>降噪，把无关的东西删掉，只学重要的东西</li></ul><h3 id="2021-11-25-4-15-PM"><a href="#2021-11-25-4-15-PM" class="headerlink" title="2021.11.25 4:15 PM"></a>2021.11.25 4:15 PM</h3><ul><li>超图和小样本</li></ul>]]></content>
    
    
    <categories>
      
      <category>FewShot Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Final Cut Pro</title>
    <link href="/2021/11/03/Final-Cut-Pro/"/>
    <url>/2021/11/03/Final-Cut-Pro/</url>
    
    <content type="html"><![CDATA[<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="/2021/11/03/Final-Cut-Pro/1.png"></p><p><strong>事件</strong>是所有素材存放的地方</p><p><strong>项目</strong>可以理解为时间线</p><hr><p>一般 1080p 25i or 4K 25i</p><p>编码器使用主流Apple ProRes 422 ，大项目可以使用Apple ProRes 4444</p><hr><p><img src="/2021/11/03/Final-Cut-Pro/2.png"></p><p>素材目录分类</p><p><strong>一定要养成事件归类的习惯</strong></p><hr><p>媒体整理三元素：<strong>关键词</strong>、<strong>分角色</strong>、<strong>片段过滤</strong></p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p><img src="/2021/11/03/Final-Cut-Pro/3.png"></p><p>要确保每个素材都写好关键词</p><hr><p><strong>视频粗剪快捷键</strong></p><p>Command + / - 素材缩放</p><p>I 入点 O出点</p><p>F 个人收藏 U 取消收藏</p><p>L 播放 K暂停 J倒放  <strong>J 和 L 按几次就是几倍速</strong></p><p>K + J 一帧一帧倒放</p><p>X 选择整条素材</p><p>；上一个编辑点 ‘ 下一个编辑点</p><hr><p><strong>分角色</strong></p><p>分角色就是给同类素材分配一个颜色即一个轨道</p><hr><p><strong>三点剪辑法</strong></p><p>入点、出点、编辑点</p><p>W 插入 根据播放头的位置来插入（会增加时长）</p><p>E 追加 出现在时间线尾部（会增加时长）</p><p>D 覆盖 </p><p>Q 连接 把两条素材连接在一起 想单独拖动按住 `</p><p>M 打标记点</p><p>A 选择</p><p>T 修建 Command + T 建立蒙太奇</p><p>Control + T 建立标题</p><p>P 可以减少素材长度 并流出灰色空隙</p><p>R 范围选择</p><p>Command R 变速</p><p>Fn D 删除留灰</p><p>按住 B不放 切割</p><p>Command B 切割</p><p>Command + Shift + B 全部素材切割</p><p>Option + 【 减去播放头左边的素材</p><p>Option + 】 减去播放头右边的素材</p><p>shift + ？ 试听前后两秒</p><hr><p>横版照片 可以在效果器里空间符合中选择填充 再 修改Y轴即可</p><p>竖版照片 可以option 按住素材往上 复制一层素材 对底层的素材放大，效果其中 高斯模糊</p><p>匹配颜色 调节白平衡</p>]]></content>
    
    
    <categories>
      
      <category>指令速查</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Meta-Learning without Memorization</title>
    <link href="/2021/10/25/Meta-Learning-without-Memorization/"/>
    <url>/2021/10/25/Meta-Learning-without-Memorization/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/10/25/Meta-Learning-without-Memorization/1.png"></p><blockquote><p>  <strong>拒绝死记硬背，元学习才能学会学习</strong></p></blockquote><h3 id="之前元学习算法存在的问题："><a href="#之前元学习算法存在的问题：" class="headerlink" title="之前元学习算法存在的问题："></a>之前元学习算法存在的问题：</h3><p>元学习解决unseen task通过：</p><ul><li>从过去的task中学习</li><li>从新任务的training data适应</li></ul><p>两者都很重要！</p><p>但是，由于task的制作不合理，无法做到完全的互斥，导致训练的元学习器是通过记忆的方式来解决训练集里的任务，而失去、减弱了解决新任务的能力。</p><p>称之为“记忆问题”（Memorization Problem）</p><h3 id="什么是“记忆问题”"><a href="#什么是“记忆问题”" class="headerlink" title="什么是“记忆问题”"></a>什么是“记忆问题”</h3><h4 id="之前元学习制作task的过程"><a href="#之前元学习制作task的过程" class="headerlink" title="之前元学习制作task的过程"></a>之前元学习制作task的过程</h4><ul><li>整个数据集分为Train、Valid、Test</li><li>随机抽样多次，每次挑选出m-way类，每类再挑选n-shot张图片，制作成很多个M-way n-shot的Tasks</li></ul><p><img src="/2021/10/25/Meta-Learning-without-Memorization/2.png">记忆问题是一种Task-level OverFitting，在Training任务重表现的很好，但是新的任务，来自Valid或者Test时，模型就GG了。</p><p>通俗的说，小学生做作业，上课老师通过几个物种的图片来教小学生辨认不同事物，小学生并没有学会如何辨认不同事物，二是直接把几个物种学会了，看似在区分这几个物种时很顺利，但是一旦遇到超纲的物种就完蛋。</p><p>再通俗的说，医生按理来说是要根据患者的症状与处方之间学会无论来什么症状的患者都会开对应的药，但是医生只是单纯的记下了以前见过的患者开的什么药，没有学会Adaption，遇到有新症状的患者，就完蛋。</p><p>回到问题本身，“记忆问题”说到底就是，在Training过程中，由于Support 和 Query标签是固定的，在Support中学习的样本，Query中都会见到，导致模型会直接记住样例，而不是学会如何Adaption。</p><h3 id="问题公式化"><a href="#问题公式化" class="headerlink" title="问题公式化"></a>问题公式化</h3><p><img src="/2021/10/25/Meta-Learning-without-Memorization/4.png"></p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><h4 id="Meta-Regularization-on-Activation"><a href="#Meta-Regularization-on-Activation" class="headerlink" title="Meta-Regularization on Activation"></a>Meta-Regularization on Activation</h4><p><img src="/2021/10/25/Meta-Learning-without-Memorization/3.png"><img src="/2021/10/25/Meta-Learning-without-Memorization/6.png"></p><h4 id="Meta-Regularization-on-Weights"><a href="#Meta-Regularization-on-Weights" class="headerlink" title="Meta-Regularization on Weights"></a>Meta-Regularization on Weights</h4><p><img src="/2021/10/25/Meta-Learning-without-Memorization/7.png"></p><h3 id="与MAML结合"><a href="#与MAML结合" class="headerlink" title="与MAML结合"></a>与MAML结合</h3><p><img src="/2021/10/25/Meta-Learning-without-Memorization/8.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>FewShot Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Meta Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How To Train Your MAML</title>
    <link href="/2021/10/23/How-To-Train-Your-MAML/"/>
    <url>/2021/10/23/How-To-Train-Your-MAML/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/10/23/How-To-Train-Your-MAML/1.png"></p><h2 id="MAML存在很多问题"><a href="#MAML存在很多问题" class="headerlink" title="MAML存在很多问题"></a>MAML存在很多问题</h2><ul><li><h3 id="训练时不问题定"><a href="#训练时不问题定" class="headerlink" title="训练时不问题定"></a>训练时不问题定</h3><p>MAML的外循环涉及通过内存换多次反响传播导数，仅有此一点就可能导致梯度问题。然而，模型的框架进一步加剧了梯度的问题，这是一个没有skip-connection的4层卷积网络。缺乏任何跳连意味着每个梯度都必须乘以相同的参数集，在多次反向传播后，展开网络的大深度结构和缺乏跳连会分别导致梯度爆炸和梯度消失</p></li><li><h3 id="对网络结构很敏感"><a href="#对网络结构很敏感" class="headerlink" title="对网络结构很敏感"></a>对网络结构很敏感</h3></li><li><h3 id="有很多超参数需要调"><a href="#有很多超参数需要调" class="headerlink" title="有很多超参数需要调"></a>有很多超参数需要调</h3></li><li><h3 id="耗时耗算力"><a href="#耗时耗算力" class="headerlink" title="耗时耗算力"></a>耗时耗算力</h3><p>梯度更新步骤涉及到计算二阶梯度，这计算非常耗时。之前的一些方法如Reptile，结果各不相同，在某些情况下超过MAML，在其他情况下产生的结果不如MAML。尚未提出在不牺牲泛化性能的同时减少计算时间的方法</p></li><li><h3 id="所有Inner-Loop共享相同的Learning-Rate"><a href="#所有Inner-Loop共享相同的Learning-Rate" class="headerlink" title="所有Inner Loop共享相同的Learning Rate"></a>所有Inner Loop共享相同的Learning Rate</h3><p>Inner Loop中所有参数和所有更新步骤共享相同学习率，这样造成问题。固定学习率需要进行多次超参数搜索才能找到特定数据集的正确学习率，这个过程的计算成本可能非常高</p></li><li><h3 id="Outer-Loop-Learning-Rate-是固定的"><a href="#Outer-Loop-Learning-Rate-是固定的" class="headerlink" title="Outer Loop Learning Rate 是固定的"></a>Outer Loop Learning Rate 是固定的</h3><p>事实证明，使用步进或余弦函数对学习率进行退火对于在多种设置中实现好的泛化性至关重要。因此我们推测使用静态学习率会降低MAML的泛化性能，也可能是优化速度较慢的原因</p></li></ul><h2 id="本文解决的问题"><a href="#本文解决的问题" class="headerlink" title="本文解决的问题"></a>本文解决的问题</h2><p>提出多种对MAML的修改，提高了稳定性，同时在加速&amp;减少计算的前提下，提高了性能，称为MAML++</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="梯度不稳定性→多步损失优化-MSL"><a href="#梯度不稳定性→多步损失优化-MSL" class="headerlink" title="梯度不稳定性→多步损失优化(MSL)"></a>梯度不稳定性→多步损失优化(MSL)</h3><p><img src="/2021/10/23/How-To-Train-Your-MAML/2.png"></p><blockquote><p>  就是改变任务的权重，一开始task权重设小，epoch变大跟着慢慢变大</p></blockquote><h3 id="二阶导数成本→导数退火DA"><a href="#二阶导数成本→导数退火DA" class="headerlink" title="二阶导数成本→导数退火DA"></a>二阶导数成本→导数退火DA</h3><p>MAML在整个训练阶段都采用了一阶近似，我们随着训练的进行对微分阶数进行退火。如在训练阶段的前50个epochs使用一阶梯度，然后在训练阶段的其余时间使用二阶梯度。</p><h3 id="缺少Batch-Normalization统计信息累积→Per-Step-Batch-Normalization运行统计信息（BNRS）"><a href="#缺少Batch-Normalization统计信息累积→Per-Step-Batch-Normalization运行统计信息（BNRS）" class="headerlink" title="缺少Batch Normalization统计信息累积→Per-Step Batch Normalization运行统计信息（BNRS）"></a>缺少Batch Normalization统计信息累积→Per-Step Batch Normalization运行统计信息（BNRS）</h3><h3 id="共享（跨步骤）Batch-Normalization偏差→Per-Step-Batch-Normalization权重和偏差（BNWB）"><a href="#共享（跨步骤）Batch-Normalization偏差→Per-Step-Batch-Normalization权重和偏差（BNWB）" class="headerlink" title="共享（跨步骤）Batch Normalization偏差→Per-Step Batch Normalization权重和偏差（BNWB）"></a>共享（跨步骤）Batch Normalization偏差→Per-Step Batch Normalization权重和偏差（BNWB）</h3><h3 id="共享的inner-loop学习率（跨步和跨参数）→学习每层每步学习率和梯度方向（LSLR）"><a href="#共享的inner-loop学习率（跨步和跨参数）→学习每层每步学习率和梯度方向（LSLR）" class="headerlink" title="共享的inner loop学习率（跨步和跨参数）→学习每层每步学习率和梯度方向（LSLR）"></a>共享的inner loop学习率（跨步和跨参数）→学习每层每步学习率和梯度方向（LSLR）</h3><h3 id="固定outer-loop学习率→元优化器学习率的余弦退火（CA）"><a href="#固定outer-loop学习率→元优化器学习率的余弦退火（CA）" class="headerlink" title="固定outer loop学习率→元优化器学习率的余弦退火（CA）"></a>固定outer loop学习率→元优化器学习率的余弦退火（CA）</h3>]]></content>
    
    
    <categories>
      
      <category>FewShot Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Meta Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win to go</title>
    <link href="/2021/10/23/Win-to-go/"/>
    <url>/2021/10/23/Win-to-go/</url>
    
    <content type="html"><![CDATA[<h3 id="设备要求"><a href="#设备要求" class="headerlink" title="设备要求"></a>设备要求</h3><ul><li>支持USB 3.1 协议</li><li>存储容量64G起步</li><li>一台windows环境系统</li><li>装驱动程序的U盘一个</li><li>鼠标（安装驱动 时用）</li></ul><h3 id="软件要求"><a href="#软件要求" class="headerlink" title="软件要求"></a>软件要求</h3><ul><li><p>windows镜像（1809不行）</p><p>必须<strong>企业版</strong></p><blockquote><p>  驱动下载：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a></p><p>  ​    <a href="https://tb.rg-adguard.net/public.php?lang=zh-CN">https://tb.rg-adguard.net/public.php?lang=zh-CN</a></p></blockquote></li><li><p>Bootcamp驱动程序</p><p>在Mac系统的Bootcamp中下载，直接下到装驱动程序的U盘中</p></li><li><p>Win to go软件</p><blockquote><p>  萝卜头WTG工具：<a href="https://bbs.luobotou.org/thread-761-1-1.html">https://bbs.luobotou.org/thread-761-1-1.html</a></p></blockquote></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>移动硬盘格式化</p><p>使用MAC自带的磁盘工具，格式选择MAC可以识别的<strong>MAC-DOS（FAT）</strong>或者 <strong>ExFAT</strong></p><p><img src="/2021/10/23/Win-to-go/1.png"></p></li><li><p>把硬盘放到Windows系统里面，打开WTG辅助工具</p><p>设置事项：</p><p>​    常用—勾选：传统、UEEI+MBR</p><p><img src="/2021/10/23/Win-to-go/2.png"></p><p>​    系统—勾选：NTFS-UEFI</p><p><img src="/2021/10/23/Win-to-go/3.png"></p><p>浏览—选择镜像文件</p><p><img src="/2021/10/23/Win-to-go/4.png"></p><p>分卷—选择要安装的window版本</p><p><img src="/2021/10/23/Win-to-go/5.png"></p><p>选择移动硬盘</p><p><img src="/2021/10/23/Win-to-go/6.png"></p><p>（大约20 min 后）</p></li><li><p>按住Option建重启电脑—选择安有window系统的移动硬盘启动—windows个性化设置</p><p>tips：由于还没有驱动，触控板不能用，需要外接鼠标，键盘可以使用windows的虚拟键盘</p></li><li><p>找到U盘里面的setup.exe安装BootCamp驱动—重启</p></li><li><p>安装完成</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2021/09/20/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/09/20/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念及操作"><a href="#基本概念及操作" class="headerlink" title="基本概念及操作"></a>基本概念及操作</h3><p>【Tab】    <strong>补全代码</strong></p><p>touch name    <strong>创建一个名为name的文件</strong></p><p>pwd    <strong>查看当前所在目录</strong></p><p>find    <strong>查找某文件</strong></p><p>【ctrl+c】    <strong>终止程序</strong></p><p>【ctrl+a】    <strong>将光标移到行头</strong></p><p>【ctrl+e】    <strong>将光标移到行末</strong></p><p>【ctrl+k】    <strong>从光标处删除到行末</strong></p><p>man     <strong>查看命令的手册</strong></p><p><strong>通配符的使用</strong></p><p>touch love_{1..10}_shiyanlou.txt     快速生成1-10的对应的十个文件 </p><p>ls *.txt    查找所有txt的文件</p><p>banner    输出图形字符</p><ul><li>sudo apt-get install sysvbanner* </li></ul><h3 id="用户及文件权限管理"><a href="#用户及文件权限管理" class="headerlink" title="用户及文件权限管理"></a>用户及文件权限管理</h3><p>who<strong>命令查看当前用户信息</strong></p><p>su     切换到用户<strong>user</strong></p><p>sudo adduser     <strong>新建一个为user的</strong>用户**</p><p>groups     查看user<strong>所属的用户组</strong></p><p>Sudo usermod -G sudo lilei    <strong>使用户获得sudo</strong></p><p>Sudo deluder lilei —remove-home    <strong>删除用户</strong></p><p>​    —<em>remove-home</em> 参数可以一并将用户的工作目录删除</p><p><img src="/2021/09/20/Linux%E5%91%BD%E4%BB%A4/1.png"></p><p>ls -l    <strong>列出所有文件及其详细</strong></p><p>ls -l     <strong>列出指定文件详细</strong></p><p>sudo chown       <strong>将文件所有者变更</strong></p><p>chmod 777     <strong>改变指定文件的权限</strong></p><h3 id="目录结构及对文件的基本操作"><a href="#目录结构及对文件的基本操作" class="headerlink" title="目录结构及对文件的基本操作"></a>目录结构及对文件的基本操作</h3><p><img src="/2021/09/20/Linux%E5%91%BD%E4%BB%A4/2.png"></p><p>cd -     <strong>返回上一次的目录</strong></p><p>cd ~    <strong>返回当前用户的home</strong></p><p>mkdir mydir    <strong>创建目录</strong></p><p>mkdir -p father/son/grandson    <strong>创建多级目录</strong></p><p>cp 文件 路径    <strong>将文件复制到指定路径下</strong></p><p>cp -r 文件 路径    <strong>递归复制</strong></p><p>rm 文件名    <strong>删除文件</strong></p><p>rm -r family    <strong>删除目录</strong></p><p>rm -f test    <strong>强制删除，针对权限不足的情况</strong></p><p>mv 文件名    目的目录    <strong>移动文件到指定目录下</strong></p><p>mv 旧文件名 新文件名    <strong>重命名</strong></p><p>cat 文件名    <strong>打印文件内容到标准输出</strong></p><p>cat -n passwd    <strong>显示行号</strong></p><p>more/less 文件名    <strong>分页查看文件</strong>    </p><p>file 文件名    <strong>查看文件的类型</strong></p><h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h3><p>:q!    <strong>放弃所有改动</strong></p><p>:wq    <strong>保存改动</strong></p><p>i    <strong>在光标钱插入文本</strong></p><p>A    <strong>在一行的最后添加文本</strong></p><p>dw     <strong>可以删除从光标处删除一个词至词的末尾</strong></p><p>d$    <strong>从光标处删除到末尾</strong></p><h3 id="环境变量和文件查找"><a href="#环境变量和文件查找" class="headerlink" title="环境变量和文件查找"></a>环境变量和文件查找</h3><p>/etc/profile    <strong>变量对所有用户生效</strong></p><p>/etc/bashrc     <strong>变量只对当前用户生效</strong></p><p>PATH=$PATH:/home/shiyanlou/mybin    <strong>添加自定义路径</strong></p><p>根据环境使用的Shell，有的是zsh，有的是bash，对应的.zshrc 和 .bashrc</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PATH=<span class="hljs-variable">$PATH</span>:/home/shiyanlou/mybin&quot;</span> &gt;&gt; .zshrc将路径复制到.zshrc文件中<br>&gt;&gt; 是追加<br>&gt;是覆盖<br></code></pre></div></td></tr></table></figure><p>source .zshrc    <strong>立即生效</strong></p><p>搜索文件：</p><p>where is <strong>简单快速</strong></p><p>locate <strong>快而全</strong> ****</p><p>locate <strong>需要先sudo update</strong></p><p>find /etc -name sources.list     查找etc文件夹下的sources.list在哪</p><p>cmatrix <strong>黑客帝国数字雨</strong></p><h3 id="文件打包和解压缩"><a href="#文件打包和解压缩" class="headerlink" title="文件打包和解压缩"></a>文件打包和解压缩</h3><p>zip -r -9 -q -o shiyanlou.zip /home/shiyanlou/Desktop</p><p>-r <strong>表示递归打包包含子目录的全部内容</strong></p><p>-q <strong>安静模式，不向屏幕输出信息</strong></p><p>-o <strong>表示输出文件</strong></p><p>unzip shiyanlou.zip    <strong>将文件解压到当前文件夹下</strong></p><p>Unzip shiyanlou.zip -d ziptest     <strong>将文件解压到指定文件夹下</strong></p><ul><li>zip：</li><li>打包 ：zip something.zip something （目录请加 -r 参数）</li><li>解包：unzip something.zip</li><li>指定路径：-d 参数</li><li>tar：</li><li>打包：tar -cf something.tar something</li><li>解包：tar -xf something.tar</li><li>指定路径：-C 参数</li></ul><h3 id="文件操作和磁盘管理"><a href="#文件操作和磁盘管理" class="headerlink" title="文件操作和磁盘管理"></a>文件操作和磁盘管理</h3><p>df    查看磁盘容量</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>sudo apt-get install XXX</p><p>sudo apt-get update    更新软件源</p><p>sudo apt-get upgrade    升级没有依赖问题的软件包</p><p>sudo apt-get remove XXX    卸载软件</p>]]></content>
    
    
    <categories>
      
      <category>指令速查</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BOIL</title>
    <link href="/2021/09/02/BOIL/"/>
    <url>/2021/09/02/BOIL/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/09/02/BOIL/1.png"></p><p><img src="/2021/09/02/BOIL/2.png"></p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>研究Representation change的作用</li><li>提出BOIL，在Inner Loop只更新Body部分参数，BOIL注重Representaion Change，不像MAML和ANIL重视Representation Reuse</li><li>BOIL取得了很好的效果，尤其是在Cross-Domain问题上</li><li>BOIL在low-/mid-level body上更倾向于Representation Reuse，在High-level body上更倾向于Representation Change</li><li>For ResNet architectures, we propose a disconnection trick that  removes the back- propagation path of the last skip connection. The  disconnection trick strengthens <em>rep- resentation layer change</em> on the high-level body</li></ul><h3 id="BOIL"><a href="#BOIL" class="headerlink" title="BOIL"></a>BOIL<a href="https://wtling.github.io/2021/11/03/BOIL/2.png"><img src="https://wtling.github.io/2021/11/03/BOIL/2.png" alt="img"></a></h3><p>做法：Inner Loop中将Hed的学习率设为0</p><h4 id="做了冻结Head的消融实验"><a href="#做了冻结Head的消融实验" class="headerlink" title="做了冻结Head的消融实验"></a>做了冻结Head的消融实验</h4><p><img src="/2021/09/02/BOIL/3.png"></p><p>​    <strong>说明冻结Head至关重要</strong></p><h4 id="特征图的相似度"><a href="#特征图的相似度" class="headerlink" title="特征图的相似度"></a>特征图的相似度</h4><p><img src="/2021/09/02/BOIL/4.png"></p><p>结果分析：</p><ul><li>Fig2a Fig2b有相似的图像，支持特征重用，他们的特征图在adaptation前后无明显变化。表面MAML/ANIL极度依赖于Meta-initialized Body，而不是Task-specific Adaptation</li><li>Fig2c有差异性的图像，支持特征改变，特征图在adaptation前后有明显变化，前三层支持特征重用，最后一个Conv支持特征改变</li></ul><p><img src="/2021/09/02/BOIL/5.png"></p><p><a href="https://wtling.github.io/2021/11/03/BOIL/5.png">CKA of 4conv</a></p><p><img src="/2021/09/02/BOIL/6.png"></p><h4 id="实验结果的分析"><a href="#实验结果的分析" class="headerlink" title="实验结果的分析"></a>实验结果的分析</h4><p><img src="/2021/09/02/BOIL/7.png">总结：MAML&amp;ANIL的meta-initialization在Adaptation前已经提供了充足的表征信息通过Body。相反BOIL没有得到充分的表征信息，所以body可以提取出更有效的表征信息</p><h4 id="BOIL只需要很少的Adaptation次数"><a href="#BOIL只需要很少的Adaptation次数" class="headerlink" title="BOIL只需要很少的Adaptation次数"></a>BOIL只需要很少的Adaptation次数</h4><p><img src="/2021/09/02/BOIL/8.png"></p><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><img src="/2021/09/02/BOIL/10.png"></p><p><img src="/2021/09/02/BOIL/12.png"></p>]]></content>
    
    
    <categories>
      
      <category>FewShot Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Meta Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash</title>
    <link href="/2021/09/02/bash/"/>
    <url>/2021/09/02/bash/</url>
    
    <content type="html"><![CDATA[<h3 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">方法1:<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1,2,3,4&#125;<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br>方法2:<br>MAX=10<br><span class="hljs-keyword">for</span>((i = 0;i &lt; MAX; i++))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br>方法3:<br>//从1输出到10<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10..1&#125;<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>指令速查</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ANIL</title>
    <link href="/2021/09/01/ANIL/"/>
    <url>/2021/09/01/ANIL/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/09/01/ANIL/1.png"></p><p><img src="/2021/09/01/ANIL/7.png"></p><h3 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h3><ul><li>消融实验证明为什么MAML有用</li><li>提出ANIL</li><li>发现，一旦模型训练好，可以不使用Inner loop，并取名*<strong>No Inner Loop（NIL）*</strong></li><li>将ANIL应用在别的元学习方法上也取得了效果</li></ul><h3 id="研究rapid-learning和feature-reuse做了以下工作："><a href="#研究rapid-learning和feature-reuse做了以下工作：" class="headerlink" title="研究rapid learning和feature reuse做了以下工作："></a>研究rapid learning和feature reuse做了以下工作：</h3><ul><li>做了Layer冻结实验</li></ul><p><img src="/2021/09/01/ANIL/2.png"></p><p>说明模型一旦训练完成之后，其实<strong>adaptation的时候参数变化的并不明显</strong></p><ul><li><p><strong>使用Representational similarity tools 直接分析inner loop对特征的变化</strong></p><ul><li><p>使用CCA 和 CKA作为特征层相似度指标</p><blockquote><p>  CCA provides a way to the compare representations of two (latent)  layers L1 , L2 of a neural network, outputting a similarity score  between 0 (not similar at all) and 1 (identical)</p><p>  To further validate this, we also compute CKA , another similarity  metric for neural network representations, which illustrates the same  pattern</p></blockquote><p><img src="/2021/09/01/ANIL/3.png"></p><p>说明Body在Adaption过程中变化不明显，而Head变化明显</p><p>而且，在MAML的10000，20000，30000迭代都表现出相同的特征相似性</p></li></ul></li></ul><h3 id="提出ANIL"><a href="#提出ANIL" class="headerlink" title="提出ANIL"></a>提出ANIL</h3><p>由于前面发现，Body有很好的重用性能，所以在Inner loop阶段只更新Head参数（ANIL），或者干脆不更新直接将meta-parameter（NIL）</p><p><img src="/2021/09/01/ANIL/4.png"></p><p><img src="/2021/09/01/ANIL/5.png"></p><h3 id="进而提出NIL"><a href="#进而提出NIL" class="headerlink" title="进而提出NIL"></a>进而提出NIL</h3><p><img src="/2021/09/01/ANIL/6.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>论文从研究，为什么MAML这么有效出发，通过一系列实验，发现Feature Reuse是MAML成功的主要因素。在此基础上设计了ANIL、NIL，在几乎不影响性能的情况下， 极大的加快了计算速度</p>]]></content>
    
    
    <categories>
      
      <category>FewShot Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Meta Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda常见命令</title>
    <link href="/2021/08/23/conda%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/23/conda%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Conda常用命令"><a href="#Conda常用命令" class="headerlink" title="Conda常用命令"></a>Conda常用命令</h2><p>conda list 查看安装了哪些包</p><p>conda env list 查看当前存在哪些虚拟环境</p><h3 id="创建Python环境"><a href="#创建Python环境" class="headerlink" title="创建Python环境"></a>创建Python环境</h3><p>conda create -n name python=X.X</p><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>source activate name</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>B &amp; B+ 树</title>
    <link href="/2021/07/20/B-B-%E6%A0%91/"/>
    <url>/2021/07/20/B-B-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="B树和B-树的区别在于："><a href="#B树和B-树的区别在于：" class="headerlink" title="B树和B+树的区别在于："></a>B树和B+树的区别在于：</h3><ul><li><p>B树的非叶子结点包含实际的值，而B+树的非叶子结点只包含索引信息，所有数据都存放在叶子结点上</p></li><li><p>由于B+树在内部节点上不含数据信息，因此在内存页中能够存放更多的key。根据数据的空间局部性原则，数据具有更好的缓存命中率</p></li><li><p>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li><li><p>B树其优点在于，由于B树的每一个节点都包含key和value，访问一些离根结点近的元素更快</p><p><img src="/2021/07/20/B-B-%E6%A0%91/1.png"></p></li></ul><hr><h3 id="B树B-树对于存储的作用"><a href="#B树B-树对于存储的作用" class="headerlink" title="B树B+树对于存储的作用"></a>B树B+树对于存储的作用</h3><p>数据库系统普遍采用B-/+Tree作为<strong>索引结构</strong></p><p>对磁盘的访问时间分为 <strong>寻道时间</strong>，<strong>旋转时间</strong>，以及<strong>传送时间</strong></p><p><img src="/2021/07/20/B-B-%E6%A0%91/2.png"></p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数</p><p>由于磁盘的物理特性就决定了其访问速度的限制，因此为了提高效率必须减少磁盘I/O。为了达到这个目的，磁盘往往不是严格的按需读取，而是会预读，即使只需要一个字节，也会一次读入一个块放入内存。这样做基于一个原理：</p><blockquote><p>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。</p></blockquote><p><strong>程序运行期间需要的数据往往比较集中</strong></p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h3 id="红黑树与B树"><a href="#红黑树与B树" class="headerlink" title="红黑树与B树"></a>红黑树与B树</h3><p><strong>为什么文件系统的索引喜欢B树而不用红黑树或者有序数组呢？</strong></p><p>文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。那么如果树都不能加载到内存中就无法查找。</p><p>而B树，每次加载树的一个结点，然后一步步往下找。</p><p>在内存中红黑树的效率高，但是在磁盘中B树就更优了</p><h3 id="为什么Mysql用B-树："><a href="#为什么Mysql用B-树：" class="headerlink" title="为什么Mysql用B+树："></a>为什么Mysql用B+树：</h3><p>​    B+树是在B树上的改造，它的数据都在叶子结点，同时叶子结点之间还加入了指针形成链表</p><p>​    而因为实际业务中一次不是只查一条记录，而是多条，如果使用B树的话，查找相邻的两个元素，可能要进行中序排序，跨层访问。而B+树所有数据都在叶子结点不需要跨层，且同时有链表结构，只需要从头找到尾，通过链表就能把所有数据取出来了</p><h3 id="Hash比B-树还快，为啥不用Hash"><a href="#Hash比B-树还快，为啥不用Hash" class="headerlink" title="Hash比B+树还快，为啥不用Hash"></a>Hash比B+树还快，为啥不用Hash</h3><p>1、这跟实际的业务场景有关，一般实际的业务场景不会只查找一条数据。一条数据确实Hash块，但是多条的话，由于B+树之间索引有序，并且有链表相连，它的查找效率就比Hash快很多了</p><p>2、而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+ 树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/2021/07/12/Trie%E6%A0%91/"/>
    <url>/2021/07/12/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>Trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串</p><p>通过共享前缀空间来节约存储空间</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a><strong>性质</strong></h3><ul><li>根节点不包含字符，除根节点意外每个节点只包含一个字符</li><li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符串不相同</li></ul><hr><p><img src="/2021/07/12/Trie%E6%A0%91/1.png"></p><p>红色的结点为结束标记，表示ab也是存储的一个串。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h3><p>​    最大的特点就是利用了字符串的公共前缀，像google、baidu搜索词条的时候，推荐相关信息</p><p>​    Trie树实现敏感词过滤：</p><p>1、先把你给我的三个敏感词：“de”, “bca”, “bcf” 建立一颗 trie 树</p><p><img src="/2021/07/12/Trie%E6%A0%91/2.png"></p><p>2、接着我们可以采用三个指针来遍历</p><p><img src="/2021/07/12/Trie%E6%A0%91/3.png"></p><p>然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格</p><p><img src="/2021/07/12/Trie%E6%A0%91/4.png"></p><p>然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动</strong></p><p><img src="/2021/07/12/Trie%E6%A0%91/5.png"></p><p>判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。</p><p><img src="/2021/07/12/Trie%E6%A0%91/4.png"></p><p>判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，<strong>不存在以字符b作为前缀的敏感词</strong>。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root</p><p><img src="/2021/07/12/Trie%E6%A0%91/5.png"></p><p>和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。</p><p><img src="/2021/07/12/Trie%E6%A0%91/6.png"></p><p>然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3和刚才一样不动</strong></p><p><img src="/2021/07/12/Trie%E6%A0%91/7.png"></p><p>判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点  e，并且，这里e是最后一个节点了，查找结束，所以存在敏感词de，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3  指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f</p><p><img src="/2021/07/12/Trie%E6%A0%91/8.png"></p><p>接着还是重复同样的步骤，知道 p3 指向最后一个字符</p><p><img src="/2021/07/12/Trie%E6%A0%91/9.png"></p><hr><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h3><p>如果敏感词长度为m，则每个敏感词查找为O（m），字符串长度为n，那么需要遍历n遍，为O(m*n)。</p><p>敏感词Trie树建立：如果有t个敏感词，O(t * m)</p><hr><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a><strong>如何实现</strong></h3><p>如果使用C++的话，我会使用unordered_set，一方面，可以自动去重，查找速度快；另一方面每个结点的子结点数目未知。</p><hr><h3 id="与KMP算法的比较"><a href="#与KMP算法的比较" class="headerlink" title="与KMP算法的比较"></a><strong>与KMP算法的比较</strong></h3><p>相比于KMP算法O（t * （m+n）），确实kmp快，但是Trie树一劳永逸，建立之后可以重复使用，而kmp算法要维护next数组，next数组根据敏感词建立，敏感词比较多的时候得不偿失。</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lambda</title>
    <link href="/2021/07/05/lambda/"/>
    <url>/2021/07/05/lambda/</url>
    
    <content type="html"><![CDATA[<p>lambda 表达式有如下的一些优点：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。<br>简洁：避免了代码膨胀和功能分散，让开发更加高效。<br>在需要的时间和地点实现功能闭包，使程序更加灵活。<br></code></pre></div></td></tr></table></figure><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-attr">[capture]</span>(params) <span class="hljs-selector-tag">opt</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">ret</span> &#123;<span class="hljs-selector-tag">body</span>;&#125;;<br></code></pre></div></td></tr></table></figure><p>其中 capture 是捕获列表，params 是参数列表，opt 是函数选项，ret 是返回值类型，body 是函数体。</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less">捕获列表 <span class="hljs-selector-attr">[]</span>: 捕获一定范围内的变量<br><br>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。<br></code></pre></div></td></tr></table></figure><p>在匿名函数内部，需要通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-string">[]</span> - 不捕捉任何变量<br><span class="hljs-string">[&amp;]</span> - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)<br><span class="hljs-string">[=]</span> - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)<br>    拷贝的副本在匿名函数体内部是只读的<br><span class="hljs-string">[=, &amp;foo]</span> - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo<br><span class="hljs-string">[bar]</span> - 按值捕获 bar 变量，同时不捕获其他变量<br><span class="hljs-string">[&amp;bar]</span> - 按引用捕获 bar 变量，同时不捕获其他变量<br><span class="hljs-string">[this]</span> - 捕获当前类中的 <span class="hljs-keyword">this</span> 指针<br>    让 lambda 表达式拥有和当前类成员函数同样的访问权限<br>    如果已经使用了 &amp; 或者 =, 默认添加此选项<br></code></pre></div></td></tr></table></figure><p>不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，但需要注意的是 labmda表达式不能通过列表初始化自动推导出返回值类型。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git工具</title>
    <link href="/2021/07/03/Git%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/07/03/Git%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">git init <span class="hljs-comment">//初始化仓库</span><br>git init newrepo<span class="hljs-comment"> //将制定文件夹作为Git仓库</span><br>git <span class="hljs-built_in">add</span> filename<span class="hljs-comment"> //添加文件</span><br>git rm <span class="hljs-built_in">file</span><span class="hljs-comment"> //删除文件</span><br>git commit -m <span class="hljs-string">&quot;Adding files&quot;</span><span class="hljs-comment"> //提交版本</span><br>git commit -<span class="hljs-keyword">a</span> -m <span class="hljs-string">&quot;Changed some files&quot;</span><br><br>git clone ssh://example.com/~/www/project.git<span class="hljs-comment"> //克隆一个库</span><br>git push ssh://example.com/~/www/project.git<span class="hljs-comment"> //推送到服务器</span><br><br>git branch branchName<span class="hljs-comment"> //创建分支</span><br>git branch -d branchName<span class="hljs-comment"> //删除分支</span><br>git checkout branchName<span class="hljs-comment"> //切换分支</span><br>第一个分支叫master<br>git checkout master<br><br>将分支合并到master上<br>git checkout master<br>git <span class="hljs-built_in">merge</span> branchName<br><br>在合并改动之前，你可以使用如下命令预览差异：<br>git diff &lt;source_branch&gt; &lt;target_branch&gt;<br><br>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 <span class="hljs-number">1.0</span><span class="hljs-number">.0</span> 的标签：<br>git tag <span class="hljs-number">1.0</span><span class="hljs-number">.0</span> <span class="hljs-number">1</span>b2e1d63ff<br><br>git <span class="hljs-built_in">log</span><br>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。<br><br>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：<br>git checkout <span class="hljs-comment">-- &lt;filename&gt;</span><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。<br><br>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：<br>git fetch origin<br>git reset <span class="hljs-comment">--hard origin/master </span><br><br>git pull 和 git fetch是有区别的<br>git fetch相当于是从远程获取最新版本到本地，不会自动<span class="hljs-built_in">merge</span><br>git pull相当于是从远程获取最新版本并<span class="hljs-built_in">merge</span>到本地<br><br></code></pre></div></td></tr></table></figure><p>本地仓库由git维护三颗树。第一个是“工作目录”，实际存储的文件；第二个是暂存取（Index），临时保存改动；最后是HEAD，指向最后一次提交的结果</p><h2 id="Git三大特色：分支、暂存取、工作流"><a href="#Git三大特色：分支、暂存取、工作流" class="headerlink" title="Git三大特色：分支、暂存取、工作流"></a>Git三大特色：分支、暂存取、工作流</h2><h3 id="Git分支："><a href="#Git分支：" class="headerlink" title="Git分支："></a>Git分支：</h3><p>​    merge方式：</p><h3 id="Git大概可以分为三个区：工作区-暂存区和版本库"><a href="#Git大概可以分为三个区：工作区-暂存区和版本库" class="headerlink" title="Git大概可以分为三个区：工作区,暂存区和版本库"></a>Git大概可以分为三个区：工作区,暂存区和版本库</h3><ul><li><p>工作区：直接编写代码的地方</p></li><li><p>暂存取：数据暂时存储的区域，连接工作区和版本库</p></li><li><p>版本库：存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了</p><p><img src="/2021/07/03/Git%E5%B7%A5%E5%85%B7/1.png"></p></li></ul><p><img src="/2021/07/03/Git%E5%B7%A5%E5%85%B7/2.png"></p><p><img src="/2021/07/03/Git%E5%B7%A5%E5%85%B7/3.png"></p><p>Git 工作流</p><p>​    工作流就是一种工作的方式，目前主流：Git Flow、Github Flow、Gitlab Flow</p><p>​    <strong>Github工作流</strong></p><p>​     GitHub Flow 推荐做法是只有一个主分支 master，团队成员们的分支代码通过 pull Request 来合并到 master 上</p><p>​    特色Pull Request：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*    </span>可以很好控制分支合并权限<br><span class="hljs-bullet">*    </span>问题讨论 或者 寻求其他小伙伴们的帮助<br><span class="hljs-bullet">*    </span>代码 Review<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>指令速查</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Laplacian-Steered Neural Style Transfer</title>
    <link href="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/"/>
    <url>/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/</url>
    
    <content type="html"><![CDATA[<h2 id="Laplacian-Steered-Neural-Style-Transfer"><a href="#Laplacian-Steered-Neural-Style-Transfer" class="headerlink" title="Laplacian-Steered Neural Style Transfer"></a>Laplacian-Steered Neural Style Transfer</h2><p><strong>传统的风格迁移项目中的问题：</strong>缺少内容图像的低级特征，而风格图像的低级特征主导了新图像的低级细节特征。因此，在合成图像中，图像内容的许多细节丢了，并且出现了很多伪像</p><p><strong>论文解决的问题：</strong>建议使用新的损失函数：*<strong>拉普拉斯损失来指导图像合成*</strong></p><p>介绍：由拉普拉斯算子生成的拉普拉斯矩阵在计算机视觉中广泛用于检测边缘和轮廓。拉普拉斯损失测量内容图像和新图像之间的拉普拉斯差异以及对应的细节结构差异，可以与传统的风格转换约束兼容。通过合并拉普拉斯损失，我们获得了神经样式转换的新优化目标，成为Lapstyle。最小化此目标将产生风格化的图像，该图像可以更好地保留内容图像的细节结构并消除伪影</p><p>拉普拉斯算子提取了一个拉普拉斯矩阵，该矩阵包括图像中对人类感知最为突出的二阶变化。这些二阶变化通常对应于细节结构</p><p><img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/1.png"></p><p><img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/2.png"></p><p>拉普拉斯损失是由两个拉普拉斯矩阵计算绝对平方差而来</p><p>拉普拉斯矩阵是由一个两层的固定的CNN来计算的，该网络由平均池化层和预先指定的卷积层组成 <a href="https://github.com/askerlee/lapstyle">https://github.com/askerlee/lapstyle</a> （源码）</p><p><strong>工作的贡献</strong></p><ul><li>提出了拉普拉斯损失</li><li>拉普拉斯损失是通过一个附加的CNN计算得到的</li><li>可以组合具有不同粒度的多个拉普拉斯损失，以捕获不同比例的图像细节结构</li></ul><hr><p><strong>拉普拉斯操作</strong>就是用<img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/3.png"></p><p>这么个卷积核来进行卷积，平滑的地方数值会小，但是边缘地带会被放大</p><p><strong>拉普拉斯损失</strong><img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/4.png"></p><p><img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/5.png"></p><p>总损失：<img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/6.png"></p><p>*<strong>在计算拉普拉斯损失的时候解决了两个问题：*</strong></p><ul><li><p>多通道上的拉普拉斯：输入的图像往往是RGB三通道，理想情况下，要检测边缘，应单独考虑每个通道，即每个通道与拉普拉斯滤波器卷积，产生三个拉普拉斯矩阵，在三个拉普拉斯矩阵中，任何一个都很大的情况下，表示边缘，无论其符号如何，为此，对于多通道的问题，最终的D 是 三个通道值绝对值之和。</p><p><img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/7.png"></p></li><li><p>通过池化层来平滑拉普拉斯矩阵结果</p></li></ul><p>此外，可以进行多个粒度的拉普拉斯操作，</p><p><img src="/2020/11/20/Laplacian-Steered-Neural-Style-Transfer/8.png"></p><hr><h3 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h3><p>拉普拉斯滤波器用3*3的固定权重的卷积层</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV</title>
    <link href="/2020/09/15/OpenCV/"/>
    <url>/2020/09/15/OpenCV/</url>
    
    <content type="html"><![CDATA[<h3 id="1-加载图片，现实图片，保存图片"><a href="#1-加载图片，现实图片，保存图片" class="headerlink" title="1.加载图片，现实图片，保存图片"></a>1.加载图片，现实图片，保存图片</h3><h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a><strong>加载图片</strong></h4><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img</span> = cv<span class="hljs-number">2</span>.imread(‘lena.jpg’,<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>参数1：图片的文件名</p><ul><li><p>如果图片放在当前文件夹下，直接写文件名就行，如’lena.jpg’</p></li><li><p>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</p></li></ul><p>参数2：读入方式，省略即采用默认值</p><ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul><h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a><strong>显示图片</strong></h4><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cv2</span>.imshow(&#x27;lena&#x27;, img)<br><span class="hljs-comment">#参数1是窗口的名字，参数2是要显示的图片</span><br><span class="hljs-attribute">cv2</span>.waitKey(<span class="hljs-number">0</span>)<br><span class="hljs-attribute">cv2</span>.waitKey( )`是让程序暂停的意思，参数是等待时间（毫秒ms）。时间一到，会继续执行接下来的程序，传入<span class="hljs-number">0</span>的话表示一直等待。等待期间也可以获取用户的按键输入：`k = cv<span class="hljs-number">2</span>.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a><strong>保存图片</strong></h4><p>使用<code>cv2.imwrite()</code>保存图片，参数1是包含后缀名的文件名：</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">cv2</span><span class="hljs-selector-class">.imwrite</span>(<span class="hljs-string">&#x27;lena_gray.jpg&#x27;</span>, img)<br></code></pre></div></td></tr></table></figure><h3 id="2-对图片的认识"><a href="#2-对图片的认识" class="headerlink" title="2.对图片的认识"></a>2.对图片的认识</h3><p><img src="/2020/09/15/OpenCV/1.jpg"></p><h3 id="3-对摄像头的操作"><a href="#3-对摄像头的操作" class="headerlink" title="3.对摄像头的操作"></a>3.对摄像头的操作</h3><h4 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a><strong>打开摄像头</strong></h4><p>要使用摄像头，需要使用<code>cv2.VideoCapture(0)</code>创建VideoCapture对象，参数0指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第2个摄像头就可以传入1，依此类推。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打开摄像头并灰度化显示</span><br><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 获取一帧</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># 将这帧转换为灰度图</span><br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, gray)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure><p><code>capture.read()</code>函数返回的第1个参数ret(return value缩写)是一个布尔值，表示当前这一帧是否获取正确。<code>cv2.cvtColor()</code>用来转换颜色，这里将彩色图转成灰度图。</p><p><code>cap.get(propId)</code>获取视频属性，<code>cap.set(propId,value)</code>设置视频属性</p><h4 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a><strong>播放本地视频</strong></h4><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>cv2.waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为25或30。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 播放本地视频</span><br>capture = cv2.VideoCapture(<span class="hljs-string">&#x27;demo_video.mp4&#x27;</span>)  <span class="hljs-comment">#参数为0代表本机摄像头</span><br><br><span class="hljs-keyword">while</span>(capture.isOpened()):<br>    ret, frame = capture.read()<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, gray)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure><h4 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a><strong>录制视频</strong></h4><p>需要创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：</p><ul><li>输出的文件名，如’output.avi’</li><li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin">FourCC</a>码</li><li>帧率<a href="https://baike.baidu.com/item/FPS/3227416">FPS</a></li><li>要保存的分辨率大小</li></ul><p>FourCC是用来指定视频编码方式的四字节码，所有的编码可参考<a href="http://www.fourcc.org/codecs.php">Video Codecs</a>。如MJPG编码可以这样写： <code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 定义编码方式并创建VideoWriter对象</span><br>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">&#x27;MJPG&#x27;</span>)<br>outfile = cv2.VideoWriter(<span class="hljs-string">&#x27;output.avi&#x27;</span>, fourcc, <span class="hljs-number">25.</span>, (<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))<br><br><span class="hljs-keyword">while</span>(capture.isOpened()):<br>    ret, frame = capture.read()<br><br>    <span class="hljs-keyword">if</span> ret:<br>        outfile.write(frame)  <span class="hljs-comment"># 写入文件</span><br>        cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, frame)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure><h3 id="4-对图像的操作"><a href="#4-对图像的操作" class="headerlink" title="4.对图像的操作"></a>4.对图像的操作</h3><h4 id="获取和修改像素点的值"><a href="#获取和修改像素点的值" class="headerlink" title="获取和修改像素点的值"></a><strong>获取和修改像素点的值</strong></h4><p>我们先读入一张图片：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>通过行列的坐标来获取某像素点的值，对于彩色图，结果是B,G,R三个值的列表，对于灰度图或单通道图，只有一个值：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">px = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>]<br><span class="hljs-built_in">print</span>(px)  <span class="hljs-comment"># [103 98 197]</span><br><br><span class="hljs-comment"># 只获取蓝色blue通道的值</span><br>px_blue = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(px_blue)  <span class="hljs-comment"># 103</span><br></code></pre></div></td></tr></table></figure><p>修改像素的值也是同样的方式：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>] = [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]<br></code></pre></div></td></tr></table></figure><p>注意：这步操作只是内存中的img像素点值变了，因为没有保存，所以原图并没有更改。</p><h4 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a><strong>ROI</strong></h4><p><a href="https://baike.baidu.com/item/ROI/1125333#viewPageContent">ROI</a>：Region of Interest</p><p>可以单独把感兴趣部位截取出来，这样就可以大大节省计算量，提高运行速度</p><p><img src="/2020/09/15/OpenCV/2.jpg"></p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-attr"># 截取脸部ROIface = img[100</span>:<span class="hljs-number">200</span>, <span class="hljs-number">115</span>:<span class="hljs-number">188</span>]cv<span class="hljs-number">2.</span>imshow<span class="hljs-comment">(&#x27;face&#x27;, face)</span>cv<span class="hljs-number">2.</span>waitKey<span class="hljs-comment">(0)</span><br></code></pre></div></td></tr></table></figure><h4 id="通道分割与合并"><a href="#通道分割与合并" class="headerlink" title="通道分割与合并"></a><strong>通道分割与合并</strong></h4><p>彩色图的BGR三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用<code>cv2.split()</code>和<code>cv2.merge()</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span>, g, r = cv2<span class="hljs-selector-class">.split</span>(img)<br><span class="hljs-selector-tag">img</span> = cv2<span class="hljs-selector-class">.merge</span>((<span class="hljs-selector-tag">b</span>, g, r))<br></code></pre></div></td></tr></table></figure><p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, :, 0]</span><br>cv2<span class="hljs-selector-class">.imshow</span>(<span class="hljs-string">&#x27;blue&#x27;</span>, b)<br>cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><h3 id="5-颜色空间转换"><a href="#5-颜色空间转换" class="headerlink" title="5.颜色空间转换"></a>5.颜色空间转换</h3><h4 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br><span class="hljs-comment"># 转换为灰度图</span><br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><br>cv2.imshow(<span class="hljs-string">&#x27;img&#x27;</span>, img)<br>cv2.imshow(<span class="hljs-string">&#x27;gray&#x27;</span>, img_gray)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p><code>cv2.cvtColor()</code>用来进行颜色模型转换，参数1是要转换的图片，参数2是转换模式， <code>COLOR_BGR2GRAY</code>表示BGR→Gray，可用下面的代码显示所有的转换模式：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">flags = <span class="hljs-selector-attr">[i for i in dir(cv2) if i.startswith(<span class="hljs-string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(flags)</span></span><br></code></pre></div></td></tr></table></figure><p><strong>经验之谈：颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R\*0.299+G\*0.587+B\*0.114</code>。</strong></p><h4 id="视频中特定颜色物体追踪"><a href="#视频中特定颜色物体追踪" class="headerlink" title="视频中特定颜色物体追踪"></a>视频中特定颜色物体追踪</h4><p><a href="https://baike.baidu.com/item/HSV/547122">HSV</a>是一个常用于颜色识别的模型，相比BGR更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p><blockquote><p>经验之谈：OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p></blockquote><p>现在，我们实现一个使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p><ol><li>捕获视频中的一帧</li><li>从BGR转换到HSV</li><li>提取蓝色范围的物体</li><li>只显示蓝色物体</li></ol><p><img src="/2020/09/15/OpenCV/3.jpg"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围，不同光照条件下不一样，可灵活调整</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br><br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br><br>    <span class="hljs-comment"># 3.inRange()：介于lower/upper之间的为白色，其余黑色</span><br>    mask = cv2.inRange(hsv, lower_blue, upper_blue)<br><br>    <span class="hljs-comment"># 4.只保留原图中的蓝色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br><br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, frame)<br>    cv2.imshow(<span class="hljs-string">&#x27;mask&#x27;</span>, mask)<br>    cv2.imshow(<span class="hljs-string">&#x27;res&#x27;</span>, res)<br><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure><p>其中，<code>bitwise_and()</code>函数暂时不用管，后面会讲到。那蓝色的HSV值的上下限lower和upper范围是怎么得到的呢？其实很简单，我们先把标准蓝色的BGR值用<code>cvtColor()</code>转换下：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">blue = np.uint8(<span class="hljs-string">[[[255, 0, 0]]</span>])<br>hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV)<br><span class="hljs-built_in">print</span>(hsv_blue)  # <span class="hljs-string">[[[120 255 255]]</span>]<br></code></pre></div></td></tr></table></figure><p>结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。</p><h3 id="6-阀值分割"><a href="#6-阀值分割" class="headerlink" title="6.阀值分割"></a>6.阀值分割</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>固定阈值分割很直接，一句话说就是像素点值大于阈值变成一类值，小于阈值变成另一类值。</p><p><img src="/2020/09/15/OpenCV/4.jpg">http</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">&#x27;gradient.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 阈值分割</span><br>ret, th = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv2.imshow(<span class="hljs-string">&#x27;thresh&#x27;</span>, th)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p><ul><li>参数1：要处理的原图，<strong>一般是灰度图</strong></li><li>参数2：设定的阈值</li><li>参数3：对于<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code>阈值方法所选用的最大阈值，一般为255</li><li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576">ThresholdTypes</a></li></ul><p>下面结合代码理解下这5种阈值方式：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 应用5种不同的阈值方法</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, th2 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, th3 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, th4 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, th5 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">&#x27;Original&#x27;</span>, <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-string">&#x27;BINARY_INV&#x27;</span>, <span class="hljs-string">&#x27;TRUNC&#x27;</span>, <span class="hljs-string">&#x27;TOZERO&#x27;</span>, <span class="hljs-string">&#x27;TOZERO_INV&#x27;</span>]<br>images = [img, th1, th2, th3, th4, th5]<br><br><span class="hljs-comment"># 使用Matplotlib显示</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i], <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 隐藏坐标轴</span><br><br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="/2020/09/15/OpenCV/5.jpg"></p><blockquote><p>经验之谈：很多人误以为阈值分割就是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%80%BC%E5%8C%96">二值化</a>。从上图中可以发现，两者并不等同，阈值分割结果是两类值，而不是两个值，所以教程开头我把二值化加了引号。</p></blockquote><p><img src="/2020/09/15/OpenCV/6.jpg"></p><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<em>它并不适用于明暗分布不均的图片</em>。 <code>cv2.adaptiveThreshold()</code>自适应阈值<strong>会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同</strong>。它有5个参数，其实很好理解，先看下效果：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 自适应阈值对比固定阈值</span><br>img = cv2.imread(<span class="hljs-string">&#x27;sudoku.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><span class="hljs-comment"># 自适应阈值</span><br>th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br>th3 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="hljs-number">17</span>, <span class="hljs-number">6</span>)<br><br>titles = [<span class="hljs-string">&#x27;Original&#x27;</span>, <span class="hljs-string">&#x27;Global(v = 127)&#x27;</span>, <span class="hljs-string">&#x27;Adaptive Mean&#x27;</span>, <span class="hljs-string">&#x27;Adaptive Gaussian&#x27;</span>]<br>images = [img, th1, th2, th3]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="/2020/09/15/OpenCV/7.jpg"></p><ul><li>参数1：要处理的原图</li><li>参数2：最大阈值，一般为255</li><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方法，只能使用<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code>，具体见前面所讲的阈值方法</li><li>参数5：小区域的面积，如11就是11*11的小块</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><h3 id="7-图像的变换"><a href="#7-图像的变换" class="headerlink" title="7.图像的变换"></a>7.图像的变换</h3><p>图像的几何变换从原理上看主要包括两种：基于2×3矩阵的仿射变换（平移、缩放、旋转和翻转等）、基于3×3矩阵的透视变换</p><p><img src="/2020/09/15/OpenCV/8.jpg"></p><p><strong>非共线的三个对应点便可确定唯一的一个仿射变换</strong>，线性变换4个自由度+平移2个自由度→<strong>仿射变换自由度为6</strong>。、</p><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>来看下OpenCV中如何实现仿射变换：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;drawing.jpg&#x27;</span>)<br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 变换前的三个点</span><br>pts1 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">210</span>, <span class="hljs-number">210</span>]])<br><span class="hljs-comment"># 变换后的三个点</span><br>pts2 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">100</span>, <span class="hljs-number">250</span>]])<br><br><span class="hljs-comment"># 生成变换矩阵</span><br>M = cv2.getAffineTransform(pts1, pts2)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img), plt.title(<span class="hljs-string">&#x27;input&#x27;</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst), plt.title(<span class="hljs-string">&#x27;output&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p>三个点已经在图中标记了出来。用<code>cv2.getAffineTransform()</code>生成变换矩阵，接下来再用<code>cv2.warpAffine()</code>实现变换。</p><p><img src="/2020/09/15/OpenCV/9.jpg"></p><table><thead><tr><th>变换</th><th>矩阵</th><th>自由度</th><th>保持性质</th></tr></thead><tbody><tr><td>平移</td><td>[I, t]（2×3）</td><td>2</td><td>方向/长度/夹角/平行性/直线性</td></tr><tr><td>刚体</td><td>[R, t]（2×3）</td><td>3</td><td>长度/夹角/平行性/直线性</td></tr><tr><td>相似</td><td>[sR, t]（2×3）</td><td>4</td><td>夹角/平行性/直线性</td></tr><tr><td>仿射</td><td>[T]（2×3）</td><td>6</td><td>平行性/直线性</td></tr><tr><td>透视</td><td>[T]（3×3）</td><td>8</td><td>直线性</td></tr></tbody></table><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><p>前面仿射变换后依然是平行四边形，并不能做到任意的变换。</p><p><img src="/2020/09/15/OpenCV/10.jpg"></p><p><a href="https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2">透视变换</a>（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维→三维→二维的一个过程。</p><p>透视变换相比仿射变换更加灵活，变换后会产生一个新的四边形，但不一定是平行四边形，所以需要<strong>非共线的四个点才能唯一确定</strong>，原图中的直线变换后依然是直线。因为四边形包括了所有的平行四边形，所以透视变换包括了所有的仿射变换。</p><p>OpenCV中首先根据变换前后的四个点用<code>cv2.getPerspectiveTransform()</code>生成3×3的变换矩阵，然后再用<code>cv2.warpPerspective()</code>进行透视变换。实战演练一下：</p><p><img src="/2020/09/15/OpenCV/11.jpg"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;card.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 原图中卡片的四个角点</span><br>pts1 = np.float32([[<span class="hljs-number">148</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">437</span>, <span class="hljs-number">114</span>], [<span class="hljs-number">94</span>, <span class="hljs-number">247</span>], [<span class="hljs-number">423</span>, <span class="hljs-number">288</span>]])<br><span class="hljs-comment"># 变换后分别在左上、右上、左下、右下四个点</span><br>pts2 = np.float32([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">178</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">178</span>]])<br><br><span class="hljs-comment"># 生成透视变换矩阵</span><br>M = cv2.getPerspectiveTransform(pts1, pts2)<br><span class="hljs-comment"># 进行透视变换，参数3是目标图像大小</span><br>dst = cv2.warpPerspective(img, M, (<span class="hljs-number">320</span>, <span class="hljs-number">178</span>))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img[:, :, ::-<span class="hljs-number">1</span>]), plt.title(<span class="hljs-string">&#x27;input&#x27;</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst[:, :, ::-<span class="hljs-number">1</span>]), plt.title(<span class="hljs-string">&#x27;output&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p>缩放就是调整图片的大小，使用<code>cv2.resize()</code>函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">&#x27;drawing.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 按照指定的宽度、高度缩放图片</span><br>res = cv2.resize(img, (<span class="hljs-number">132</span>, <span class="hljs-number">150</span>))<br><span class="hljs-comment"># 按照比例缩放，如x,y轴均放大一倍</span><br>res2 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">2</span>, fy=<span class="hljs-number">2</span>, interpolation=cv2.INTER_LINEAR)<br><br>cv2.imshow(<span class="hljs-string">&#x27;shrink&#x27;</span>, res), cv2.imshow(<span class="hljs-string">&#x27;zoom&#x27;</span>, res2)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>我们也可以指定缩放方法<code>interpolation</code>，更专业点叫插值方法，默认是<code>INTER_LINEAR</code></p><p>镜像翻转图片，可以用<code>cv2.flip()</code>函数：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">dst</span> = cv<span class="hljs-number">2</span>.flip(img, <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>其中，参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</p><p><img src="/2020/09/15/OpenCV/12.jpg"></p><h4 id="-2"><a href="#-2" class="headerlink" title></a></h4><p>要平移图片，我们需要定义下面这样一个矩阵，tx,ty是向x和y方向平移的距离：</p><p>M=[10tx01ty] M = \left[ </p><p>  \right] M=[10tx01ty]</p><p>平移是用仿射变换函数<code>cv2.warpAffine()</code>实现的：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 平移图片</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 定义平移矩阵，需要是numpy的float32类型</span><br><span class="hljs-comment"># x轴平移100，y轴平移50</span><br>M = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>]])<br><span class="hljs-comment"># 用仿射变换实现平移</span><br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">&#x27;shift&#x27;</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><h4 id="-3"><a href="#-3" class="headerlink" title></a><img src="/2020/09/15/OpenCV/13.jpg"></h4><p>旋转同平移一样，也是用仿射变换实现的，因此也需要定义一个变换矩阵。OpenCV直接提供了 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p><ul><li>参数1：图片的旋转中心</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5表示缩小一半</li></ul><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 45°旋转图片并缩小一半</span><br><span class="hljs-attribute">M</span> = cv<span class="hljs-number">2</span>.getRotationMatrix<span class="hljs-number">2</span>D((cols / <span class="hljs-number">2</span>, rows / <span class="hljs-number">2</span>), <span class="hljs-number">45</span>, <span class="hljs-number">0</span>.<span class="hljs-number">5</span>)<br><span class="hljs-attribute">dst</span> = cv<span class="hljs-number">2</span>.warpAffine(img, M, (cols, rows))<br><br><span class="hljs-attribute">cv2</span>.imshow(&#x27;rotation&#x27;, dst)<br><span class="hljs-attribute">cv2</span>.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p><img src="/2020/09/15/OpenCV/14.jpg"></p><h3 id="8-代码性能优化的方法"><a href="#8-代码性能优化的方法" class="headerlink" title="8.代码性能优化的方法"></a>8.代码性能优化的方法</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> cv<span class="hljs-number">2</span><br><br><span class="hljs-attribute">start</span> = cv<span class="hljs-number">2</span>.getTickCount()<br><span class="hljs-comment"># 这里写测试代码...</span><br><span class="hljs-attribute">end</span> = cv<span class="hljs-number">2</span>.getTickCount()<br><span class="hljs-attribute">print</span>((end - start) / cv<span class="hljs-number">2</span>.getTickFrequency())<br></code></pre></div></td></tr></table></figure><p>这段代码就是用来测量程序运行时间的（单位：s），其中<code>cv2.getTickCount()</code>函数得到电脑启动以来的时钟周期数，<code>cv2.getTickFrequency()</code>返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用Python中的time模块计时：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">import <span class="hljs-built_in">time</span><br><br>start = <span class="hljs-built_in">time</span>.<span class="hljs-built_in">clock</span>()<br># 这里写测试代码...<br><span class="hljs-keyword">end</span> = <span class="hljs-built_in">time</span>.<span class="hljs-built_in">clock</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">end</span> - start)<br></code></pre></div></td></tr></table></figure><h4 id="-4"><a href="#-4" class="headerlink" title></a></h4><ul><li>数据元素少时用Python语法，数据元素多时用Numpy：</li></ul><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = <span class="hljs-number">10</span><br><span class="hljs-attribute">z</span> = np.uint<span class="hljs-number">8</span>([<span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># 尝试比较下面三句话各自的运行时间</span><br><span class="hljs-attribute">y</span> = x * x * x   # (<span class="hljs-number">1</span>.<span class="hljs-number">6410249677846285</span>e-<span class="hljs-number">06</span>)<br><span class="hljs-attribute">y</span> = x**<span class="hljs-number">3</span>        # (<span class="hljs-number">2</span>.<span class="hljs-number">461537451676943</span>e-<span class="hljs-number">06</span>)<br><span class="hljs-attribute">y</span> = z * z * z   # 最慢 (<span class="hljs-number">3</span>.<span class="hljs-number">1179474387907945</span>e-<span class="hljs-number">05</span>)<br></code></pre></div></td></tr></table></figure><p>所以Numpy的运行速度并不一定比Python本身语法快，元素数量较少时，请用Python本身格式。</p><ul><li>尽量避免使用循环，尤其嵌套循环，因为极其慢！！！</li><li>优先使用OpenCV/Numpy中封装好的函数</li><li>尽量将数据向量化，变成Numpy的数据格式</li><li>尽量避免数组的复制操作</li></ul><h3 id="9-无损保存和Matplotlib"><a href="#9-无损保存和Matplotlib" class="headerlink" title="9.无损保存和Matplotlib"></a>9.无损保存和Matplotlib</h3><h4 id="-5"><a href="#-5" class="headerlink" title></a></h4><ul><li>bmp<ul><li>全称：Bitmap</li><li><strong>不压缩</strong></li></ul></li><li>jpg<ul><li>全称：Joint Photographic Experts Group</li><li><strong>有损压缩方式</strong></li></ul></li><li>png<ul><li>全称：Portable Network Graphics</li><li><strong>无损压缩方式</strong></li></ul></li></ul><h4 id="-6"><a href="#-6" class="headerlink" title></a></h4><p>用<code>cv2.imwrite()</code>保存图片时，可以传入第三个参数（请参考<a href="http://codec.wang/#/">接口文档</a>），用于控制保存质量：</p><ul><li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg质量控制，取值0~100，值越大，质量越好，默认为95</li><li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png质量控制，取值0~9，值越大，压缩比越高，默认为1</li></ul><p>还有诸如<code>CV_IMWRITE_WEBP_QUALITY</code>的参量，不常用，请参考：<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac">ImwriteFlags</a>。</p><p>举例来说，原图lena.jpg的分辨率是350×350，大小49.7KB。我们把它转成不同格式看下：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">new</span><span class="hljs-type">_img</span> = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br><br><span class="hljs-meta"># bmp</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_bmp.bmp&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>) <span class="hljs-meta"># 文件大小：359KB</span><br><br><span class="hljs-meta"># jpg 默认95%质量</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_jpg95.jpg&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>) <span class="hljs-meta"># 文件大小：52.3KB</span><br><span class="hljs-meta"># jpg 20%质量</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_jpg20.jpg&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>,[int(cv2.IMWRITE_JPEG_QUALITY),<span class="hljs-number">20</span>]) <span class="hljs-meta"># 文件大小：8.01KB</span><br><span class="hljs-meta"># jpg 100%质量</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_jpg100.jpg&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>,[int(cv2.IMWRITE_JPEG_QUALITY),<span class="hljs-number">100</span>]) <span class="hljs-meta"># 文件大小：82.5KB</span><br><br><span class="hljs-meta"># png 默认1压缩比</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_png1.png&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>) <span class="hljs-meta"># 文件大小：240KB</span><br><span class="hljs-meta"># png 9压缩比</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_png9.png&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>,[int(cv2.IMWRITE_PNG_COMPRESSION),<span class="hljs-number">9</span>]) <span class="hljs-meta"># 文件大小：207KB</span><br></code></pre></div></td></tr></table></figure><p>可以看到：</p><ul><li>bmp文件是最大的，没有任何压缩（1个像素点1byte，3通道的彩色图总大小：350×350×3/1024 ≈ 359 KB）</li><li>jpg/png本身就有压缩的，所以就算是100%的质量保存，体积也比bmp小很多</li><li>jpg的容量优势很明显，这也是它为什么如此流行的原因</li></ul><p>这里需要明确的是保存新格式时，<strong>容量大小跟原图的容量没有直接关系，而是取决于原图的分辨率大小和原图本身的内容（压缩方式）</strong>，所以lena.jpg保存成不压缩的bmp格式时，容量大小就是固定的350×350×3/1024 ≈ 359 KB；另外，容量变大不代表画质提升</p><h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br># 灰度图显示，cmap(color map)设置为gray<br>plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p>结果如下：</p><h4 id="-8"><a href="#-8" class="headerlink" title></a><img src="/2020/09/15/OpenCV/15.jpg"></h4><p><strong>OpenCV中的图像是以BGR的通道顺序存储的</strong>，<strong>但Matplotlib是以RGB模式显示的，所以直接在Matplotlib中显示OpenCV图像会出现问题，因此需要转换一下:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">import cv<span class="hljs-number">2</span><br>import matplotlib.pyplot as plt<br><br>img = cv<span class="hljs-number">2.</span>imread<span class="hljs-comment">(&#x27;lena.jpg&#x27;)</span><br>im<span class="hljs-name">g2</span> = img[:, :, ::<span class="hljs-number">-1</span>]<br><span class="hljs-attr"># 或使用</span><br><span class="hljs-attr"># img2</span> = cv<span class="hljs-number">2.</span>cvtColor<span class="hljs-comment">(img, cv2.COLOR_BGR2RGB)</span><br><br><span class="hljs-attr"># 显示不正确的图</span><br><span class="hljs-attr">plt.subplot(121</span>),plt.imshow<span class="hljs-comment">(img)</span> <br><br><span class="hljs-attr"># 显示正确的图</span><br><span class="hljs-attr">plt.subplot(122</span>)<br>plt.xticks<span class="hljs-comment">([])</span>, plt.yticks<span class="hljs-comment">([])</span> <span class="hljs-attr"># 隐藏x和y轴</span><br><span class="hljs-attr">plt.imshow(img2</span>)<br><br>plt.show<span class="hljs-comment">()</span><br></code></pre></div></td></tr></table></figure><blockquote><p><code>img[:,:,0]</code>表示图片的蓝色通道，<code>img[:,:,::-1]</code>就表示BGR翻转，变成RGB，说明一下：</p></blockquote><p>对一个字符串s翻转可以这样写：<code>s[::-1]</code>，’abc’变成’cba’，-1表示逆序。图片是二维的，所以完整地复制一副图像就是：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img2</span> = img[:,:] # 写全就是：img<span class="hljs-number">2</span> = img[<span class="hljs-number">0</span>:height,<span class="hljs-number">0</span>:width]<br></code></pre></div></td></tr></table></figure><p>而图片是有三个通道，相当于一个长度为3的字符串，所以通道翻转与图片复制组合起来便是<code>img[:,:,::-1]</code>。</p><p>结果如下：</p><p><img src="/2020/09/15/OpenCV/16.jpg"></p><h4 id="-9"><a href="#-9" class="headerlink" title></a></h4><p>不使用OpenCV，Matplotlib也可以加载和保存图片：</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> matplotlib.image <span class="hljs-keyword">as</span> pli<br><br>img = pli.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br>plt.imshow(img)<br><br># 保存图片，需放在<span class="hljs-keyword">show</span>()函数之前<br>plt.savefig(<span class="hljs-string">&#x27;lena2.jpg&#x27;</span>)<br>plt.<span class="hljs-keyword">show</span>()<br></code></pre></div></td></tr></table></figure><h3 id="10-图像混合"><a href="#10-图像混合" class="headerlink" title="10.图像混合"></a>10.图像混合</h3><h4 id="-10"><a href="#-10" class="headerlink" title></a></h4><p>要叠加两张图片，可以用<code>cv2.add()</code>函数，相加两幅图片的形状（高度/宽度/通道数）必须相同。numpy中可以直接用res = img + img1相加，但这两者的结果并不相同：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = np.uint<span class="hljs-number">8</span>([<span class="hljs-number">250</span>])<br><span class="hljs-attribute">y</span> = np.uint<span class="hljs-number">8</span>([<span class="hljs-number">10</span>])<br><span class="hljs-attribute">print</span>(cv<span class="hljs-number">2</span>.add(x, y))  # <span class="hljs-number">250</span>+<span class="hljs-number">10</span> = <span class="hljs-number">260</span> =&gt; <span class="hljs-number">255</span><br><span class="hljs-attribute">print</span>(x + y)  # <span class="hljs-number">250</span>+<span class="hljs-number">10</span> = <span class="hljs-number">260</span> % <span class="hljs-number">256</span> = <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>如果是二值化图片（只有0和255两种值），两者结果是一样的（用numpy的方式更简便一些）。</p><h4 id="-11"><a href="#-11" class="headerlink" title></a></h4><p>图像混合<code>cv2.addWeighted()</code>也是一种图片相加的操作，只不过两幅图片的权重不一样，γ相当于一个修正值：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img1</span> = cv<span class="hljs-number">2</span>.imread(&#x27;lena_small.jpg&#x27;)img<span class="hljs-number">2</span> = cv<span class="hljs-number">2</span>.imread(&#x27;opencv-logo-white.png&#x27;)res = cv<span class="hljs-number">2</span>.addWeighted(img<span class="hljs-number">1</span>, <span class="hljs-number">0</span>.<span class="hljs-number">6</span>, img<span class="hljs-number">2</span>, <span class="hljs-number">0</span>.<span class="hljs-number">4</span>, <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p><img src="/2020/09/15/OpenCV/17.jpg"></p><blockquote><p>经验之谈：α和β都等于1时，就相当于图片相加。</p></blockquote><h4 id="-12"><a href="#-12" class="headerlink" title></a></h4><p>按位操作包括按位与/或/非/异或操作，有什么用途呢？比如说我们要实现下图的效果：</p><p><img src="/2020/09/15/OpenCV/18.jpg"></p><p>如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作。首先来了解一下<a href="https://baike.baidu.com/item/%E6%8E%A9%E8%86%9C/8544392?fr=aladdin">掩膜</a>（mask）的概念：掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡，看下图就一目了然了：</p><p><img src="/2020/09/15/OpenCV/19.jpg"></p><p>所以我们的思路就是把原图中要放logo的区域抠出来，再把logo放进去就行了：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img1</span> = cv<span class="hljs-number">2</span>.imread(&#x27;lena.jpg&#x27;)<br><span class="hljs-attribute">img2</span> = cv<span class="hljs-number">2</span>.imread(&#x27;opencv-logo-white.png&#x27;)<br><br><span class="hljs-comment"># 把logo放在左上角，所以我们只关心这一块区域</span><br><span class="hljs-attribute">rows</span>, cols = img<span class="hljs-number">2</span>.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-attribute">roi</span> = img<span class="hljs-number">1</span>[:rows, :cols]<br><br><span class="hljs-comment"># 创建掩膜</span><br><span class="hljs-attribute">img2gray</span> = cv<span class="hljs-number">2</span>.cvtColor(img<span class="hljs-number">2</span>, cv<span class="hljs-number">2</span>.COLOR_BGR<span class="hljs-number">2</span>GRAY)<br><span class="hljs-attribute">ret</span>, mask = cv<span class="hljs-number">2</span>.threshold(img<span class="hljs-number">2</span>gray, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, cv<span class="hljs-number">2</span>.THRESH_BINARY)<br><span class="hljs-attribute">mask_inv</span> = cv<span class="hljs-number">2</span>.bitwise_not(mask)<br><br><span class="hljs-comment"># 保留除logo外的背景</span><br><span class="hljs-attribute">img1_bg</span> = cv<span class="hljs-number">2</span>.bitwise_and(roi, roi, mask=mask_inv)<br><span class="hljs-attribute">dst</span> = cv<span class="hljs-number">2</span>.add(img<span class="hljs-number">1</span>_bg, img<span class="hljs-number">2</span>)  # 进行融合<br><span class="hljs-attribute">img1</span>[:rows, :cols] = dst  # 融合后放在原图上<br></code></pre></div></td></tr></table></figure><h3 id="11-平滑图像"><a href="#11-平滑图像" class="headerlink" title="11.平滑图像"></a>11.平滑图像</h3><h4 id="-13"><a href="#-13" class="headerlink" title></a></h4><p>关于滤波和模糊</p><ul><li>它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言）</li><li>低通滤波器是模糊，高通滤波器是锐化</li></ul><p>低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，<strong>所以低通滤波器用于去除噪点、平滑和模糊图像</strong>。<strong>高通滤波器则反之，用来增强图像边缘，进行锐化处理。</strong></p><blockquote><p>常见噪声有<a href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958?fr=aladdin">椒盐噪声</a>和<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p></blockquote><h4 id="-14"><a href="#-14" class="headerlink" title></a></h4><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p><p>kernel=19[111111111] kernel = \frac{1}{9}\left[ </p><p>  \right] kernel=91[111111111]</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">img</span> = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br><span class="hljs-attr">blur</span> = cv2.blur(img, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 均值模糊</span><br></code></pre></div></td></tr></table></figure><blockquote><p>所有的滤波函数都有一个可选参数borderType，这个参数就是<a href="http://codec.wang/#/Extra-08-Padding-and-Convolution/">番外篇：卷积基础(图片边框)</a>中所说的边框填充方式。</p></blockquote><h4 id="-15"><a href="#-15" class="headerlink" title></a></h4><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p><p>k=a[111111111] k = a\left[ </p><p>  \right] k=a[111111111]</p><p>用<code>cv2.boxFilter()</code>函数实现，当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1/9；normalize为False的时候，a=1，相当于求区域内的像素和。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span><br><span class="hljs-attribute">blur</span> = cv<span class="hljs-number">2</span>.boxFilter(img, -<span class="hljs-number">1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), normalize=True)<br></code></pre></div></td></tr></table></figure><h4 id="-16"><a href="#-16" class="headerlink" title></a></h4><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，来，数学时间( ╯□╰ )，还记得标准正态分布的曲线吗？</p><p><img src="/2020/09/15/OpenCV/20.jpg"></p><p>显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a href="https://en.wikipedia.org/wiki/Gaussian_filter">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的<a href="http://codec.wang/#/">番外小篇</a>）：</p><p>k=[0.06250.1250.06250.1250.250.1250.06250.1250.0625] k = \left[ </p><p>  \right] k=[0.06250.1250.06250.1250.250.1250.06250.1250.0625]</p><p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">img</span> = cv2.imread(<span class="hljs-string">&#x27;gaussian_noise.bmp&#x27;</span>)<br><span class="hljs-comment"># 均值滤波vs高斯滤波</span><br><span class="hljs-attr">blur</span> = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br><span class="hljs-attr">gaussian</span> = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">1</span>)  <span class="hljs-comment"># 高斯滤波</span><br></code></pre></div></td></tr></table></figure><p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p><p><img src="/2020/09/15/OpenCV/21.jpg"></p><h4 id="-17"><a href="#-17" class="headerlink" title></a></h4><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%80%BC">中值</a>又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，适用于去除椒盐噪声和斑点噪声。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p><p>比如下面这张斑点噪声图，用中值滤波显然更好：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">img</span> = cv2.imread(<span class="hljs-string">&#x27;salt_noise.bmp&#x27;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 均值滤波vs中值滤波</span><br><span class="hljs-attr">blur</span> = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br><span class="hljs-attr">median</span> = cv2.medianBlur(img, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 中值滤波</span><br></code></pre></div></td></tr></table></figure><h4 id="-18"><a href="#-18" class="headerlink" title></a><img src="/2020/09/15/OpenCV/22.jpg"></h4><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a href="https://baike.baidu.com/item/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2">双边滤波</a>。用<code>cv2.bilateralFilter()</code>函数实现：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img</span> = cv<span class="hljs-number">2</span>.imread(&#x27;lena.jpg&#x27;)<br><span class="hljs-comment"># 双边滤波vs高斯滤波</span><br><span class="hljs-attribute">gau</span> = cv<span class="hljs-number">2</span>.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)  # 高斯滤波<br><span class="hljs-attribute">blur</span> = cv<span class="hljs-number">2</span>.bilateralFilter(img, <span class="hljs-number">9</span>, <span class="hljs-number">75</span>, <span class="hljs-number">75</span>)  # 双边滤波<br></code></pre></div></td></tr></table></figure><p><img src="/2020/09/15/OpenCV/23.jpg"></p><p>可以看到，双边滤波明显保留了更多边缘信息。</p>]]></content>
    
    
    <categories>
      
      <category>指令速查</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
</search>
