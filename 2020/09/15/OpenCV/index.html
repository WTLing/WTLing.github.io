

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E6%B5%B7%E7%BB%B5%E5%AE%9D%E5%AE%9D.png">
  <link rel="icon" href="/img/%E6%B5%B7%E7%BB%B5%E5%AE%9D%E5%AE%9D.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="ZTDXMC">
  <meta name="keywords" content="">
  <meta name="description" content="1.加载图片，现实图片，保存图片加载图片1img &#x3D; cv2.imread(‘lena.jpg’,0)  参数1：图片的文件名  如果图片放在当前文件夹下，直接写文件名就行，如’lena.jpg’  否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’   参数2：读入方式，省略即采用默认值  cv2.IMREAD_COLOR：彩色图，默认值(1) cv2.IMREAD_">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV">
<meta property="og:url" content="http://example.com/2020/09/15/OpenCV/index.html">
<meta property="og:site_name" content="Tony的窝点">
<meta property="og:description" content="1.加载图片，现实图片，保存图片加载图片1img &#x3D; cv2.imread(‘lena.jpg’,0)  参数1：图片的文件名  如果图片放在当前文件夹下，直接写文件名就行，如’lena.jpg’  否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’   参数2：读入方式，省略即采用默认值  cv2.IMREAD_COLOR：彩色图，默认值(1) cv2.IMREAD_">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/1.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/2.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/3.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/4.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/5.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/6.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/7.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/8.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/9.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/10.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/11.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/12.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/13.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/14.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/15.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/16.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/17.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/18.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/19.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/20.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/21.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/22.jpg">
<meta property="og:image" content="http://example.com/2020/09/15/OpenCV/23.jpg">
<meta property="article:published_time" content="2020-09-15T14:25:23.000Z">
<meta property="article:modified_time" content="2021-11-23T14:36:38.133Z">
<meta property="article:author" content="ZTDXMC">
<meta property="article:tag" content="OpenCV">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2020/09/15/OpenCV/1.jpg">
  
  <title>OpenCV - Tony的窝点</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"d311059c1b774ee7657bb02e7ecfd0fb","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tony的窝点</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                All
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Category
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tag
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/%E5%AF%8C%E5%A3%AB%E5%B1%B1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="OpenCV">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-15 22:25" pubdate>
        2020年9月15日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      46 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">OpenCV</h1>
            
            <div class="markdown-body">
              <h3 id="1-加载图片，现实图片，保存图片"><a href="#1-加载图片，现实图片，保存图片" class="headerlink" title="1.加载图片，现实图片，保存图片"></a>1.加载图片，现实图片，保存图片</h3><h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a><strong>加载图片</strong></h4><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img</span> = cv<span class="hljs-number">2</span>.imread(‘lena.jpg’,<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p>参数1：图片的文件名</p>
<ul>
<li><p>如果图片放在当前文件夹下，直接写文件名就行，如’lena.jpg’</p>
</li>
<li><p>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</p>
</li>
</ul>
<p>参数2：读入方式，省略即采用默认值</p>
<ul>
<li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li>
<li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li>
<li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li>
</ul>
<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a><strong>显示图片</strong></h4><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cv2</span>.imshow(&#x27;lena&#x27;, img)<br><span class="hljs-comment">#参数1是窗口的名字，参数2是要显示的图片</span><br><span class="hljs-attribute">cv2</span>.waitKey(<span class="hljs-number">0</span>)<br><span class="hljs-attribute">cv2</span>.waitKey( )`是让程序暂停的意思，参数是等待时间（毫秒ms）。时间一到，会继续执行接下来的程序，传入<span class="hljs-number">0</span>的话表示一直等待。等待期间也可以获取用户的按键输入：`k = cv<span class="hljs-number">2</span>.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a><strong>保存图片</strong></h4><p>使用<code>cv2.imwrite()</code>保存图片，参数1是包含后缀名的文件名：</p>
<figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">cv2</span><span class="hljs-selector-class">.imwrite</span>(<span class="hljs-string">&#x27;lena_gray.jpg&#x27;</span>, img)<br></code></pre></div></td></tr></table></figure>

<h3 id="2-对图片的认识"><a href="#2-对图片的认识" class="headerlink" title="2.对图片的认识"></a>2.对图片的认识</h3><p><img src="/2020/09/15/OpenCV/1.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-对摄像头的操作"><a href="#3-对摄像头的操作" class="headerlink" title="3.对摄像头的操作"></a>3.对摄像头的操作</h3><h4 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a><strong>打开摄像头</strong></h4><p>要使用摄像头，需要使用<code>cv2.VideoCapture(0)</code>创建VideoCapture对象，参数0指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第2个摄像头就可以传入1，依此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 打开摄像头并灰度化显示</span><br><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 获取一帧</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># 将这帧转换为灰度图</span><br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, gray)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure>

<p><code>capture.read()</code>函数返回的第1个参数ret(return value缩写)是一个布尔值，表示当前这一帧是否获取正确。<code>cv2.cvtColor()</code>用来转换颜色，这里将彩色图转成灰度图。</p>
<p><code>cap.get(propId)</code>获取视频属性，<code>cap.set(propId,value)</code>设置视频属性</p>
<h4 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a><strong>播放本地视频</strong></h4><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>cv2.waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为25或30。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 播放本地视频</span><br>capture = cv2.VideoCapture(<span class="hljs-string">&#x27;demo_video.mp4&#x27;</span>)  <span class="hljs-comment">#参数为0代表本机摄像头</span><br><br><span class="hljs-keyword">while</span>(capture.isOpened()):<br>    ret, frame = capture.read()<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, gray)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure>

<h4 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a><strong>录制视频</strong></h4><p>需要创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：</p>
<ul>
<li>输出的文件名，如’output.avi’</li>
<li>编码方式<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin">FourCC</a>码</li>
<li>帧率<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FPS/3227416">FPS</a></li>
<li>要保存的分辨率大小</li>
</ul>
<p>FourCC是用来指定视频编码方式的四字节码，所有的编码可参考<a target="_blank" rel="noopener" href="http://www.fourcc.org/codecs.php">Video Codecs</a>。如MJPG编码可以这样写： <code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 定义编码方式并创建VideoWriter对象</span><br>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">&#x27;MJPG&#x27;</span>)<br>outfile = cv2.VideoWriter(<span class="hljs-string">&#x27;output.avi&#x27;</span>, fourcc, <span class="hljs-number">25.</span>, (<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))<br><br><span class="hljs-keyword">while</span>(capture.isOpened()):<br>    ret, frame = capture.read()<br><br>    <span class="hljs-keyword">if</span> ret:<br>        outfile.write(frame)  <span class="hljs-comment"># 写入文件</span><br>        cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, frame)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure>

<h3 id="4-对图像的操作"><a href="#4-对图像的操作" class="headerlink" title="4.对图像的操作"></a>4.对图像的操作</h3><h4 id="获取和修改像素点的值"><a href="#获取和修改像素点的值" class="headerlink" title="获取和修改像素点的值"></a><strong>获取和修改像素点的值</strong></h4><p>我们先读入一张图片：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br></code></pre></div></td></tr></table></figure>

<p>通过行列的坐标来获取某像素点的值，对于彩色图，结果是B,G,R三个值的列表，对于灰度图或单通道图，只有一个值：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">px = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>]<br><span class="hljs-built_in">print</span>(px)  <span class="hljs-comment"># [103 98 197]</span><br><br><span class="hljs-comment"># 只获取蓝色blue通道的值</span><br>px_blue = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(px_blue)  <span class="hljs-comment"># 103</span><br></code></pre></div></td></tr></table></figure>

<p>修改像素的值也是同样的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>] = [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]<br></code></pre></div></td></tr></table></figure>

<p>注意：这步操作只是内存中的img像素点值变了，因为没有保存，所以原图并没有更改。</p>
<h4 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a><strong>ROI</strong></h4><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ROI/1125333#viewPageContent">ROI</a>：Region of Interest</p>
<p>可以单独把感兴趣部位截取出来，这样就可以大大节省计算量，提高运行速度</p>
<p><img src="/2020/09/15/OpenCV/2.jpg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-attr"># 截取脸部ROIface = img[100</span>:<span class="hljs-number">200</span>, <span class="hljs-number">115</span>:<span class="hljs-number">188</span>]cv<span class="hljs-number">2.</span>imshow<span class="hljs-comment">(&#x27;face&#x27;, face)</span>cv<span class="hljs-number">2.</span>waitKey<span class="hljs-comment">(0)</span><br></code></pre></div></td></tr></table></figure>

<h4 id="通道分割与合并"><a href="#通道分割与合并" class="headerlink" title="通道分割与合并"></a><strong>通道分割与合并</strong></h4><p>彩色图的BGR三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用<code>cv2.split()</code>和<code>cv2.merge()</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span>, g, r = cv2<span class="hljs-selector-class">.split</span>(img)<br><span class="hljs-selector-tag">img</span> = cv2<span class="hljs-selector-class">.merge</span>((<span class="hljs-selector-tag">b</span>, g, r))<br></code></pre></div></td></tr></table></figure>

<p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, :, 0]</span><br>cv2<span class="hljs-selector-class">.imshow</span>(<span class="hljs-string">&#x27;blue&#x27;</span>, b)<br>cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<h3 id="5-颜色空间转换"><a href="#5-颜色空间转换" class="headerlink" title="5.颜色空间转换"></a>5.颜色空间转换</h3><h4 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br><span class="hljs-comment"># 转换为灰度图</span><br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><br>cv2.imshow(<span class="hljs-string">&#x27;img&#x27;</span>, img)<br>cv2.imshow(<span class="hljs-string">&#x27;gray&#x27;</span>, img_gray)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p><code>cv2.cvtColor()</code>用来进行颜色模型转换，参数1是要转换的图片，参数2是转换模式， <code>COLOR_BGR2GRAY</code>表示BGR→Gray，可用下面的代码显示所有的转换模式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">flags = <span class="hljs-selector-attr">[i for i in dir(cv2) if i.startswith(<span class="hljs-string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(flags)</span></span><br></code></pre></div></td></tr></table></figure>

<p><strong>经验之谈：颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R\*0.299+G\*0.587+B\*0.114</code>。</strong></p>
<h4 id="视频中特定颜色物体追踪"><a href="#视频中特定颜色物体追踪" class="headerlink" title="视频中特定颜色物体追踪"></a>视频中特定颜色物体追踪</h4><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HSV/547122">HSV</a>是一个常用于颜色识别的模型，相比BGR更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p>
<blockquote>
<p>经验之谈：OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p>
</blockquote>
<p>现在，我们实现一个使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p>
<ol>
<li>捕获视频中的一帧</li>
<li>从BGR转换到HSV</li>
<li>提取蓝色范围的物体</li>
<li>只显示蓝色物体</li>
</ol>
<p><img src="/2020/09/15/OpenCV/3.jpg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围，不同光照条件下不一样，可灵活调整</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br><br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br><br>    <span class="hljs-comment"># 3.inRange()：介于lower/upper之间的为白色，其余黑色</span><br>    mask = cv2.inRange(hsv, lower_blue, upper_blue)<br><br>    <span class="hljs-comment"># 4.只保留原图中的蓝色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br><br>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>, frame)<br>    cv2.imshow(<span class="hljs-string">&#x27;mask&#x27;</span>, mask)<br>    cv2.imshow(<span class="hljs-string">&#x27;res&#x27;</span>, res)<br><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure>

<p>其中，<code>bitwise_and()</code>函数暂时不用管，后面会讲到。那蓝色的HSV值的上下限lower和upper范围是怎么得到的呢？其实很简单，我们先把标准蓝色的BGR值用<code>cvtColor()</code>转换下：</p>
<figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">blue = np.uint8(<span class="hljs-string">[[[255, 0, 0]]</span>])<br>hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV)<br><span class="hljs-built_in">print</span>(hsv_blue)  # <span class="hljs-string">[[[120 255 255]]</span>]<br></code></pre></div></td></tr></table></figure>

<p>结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。</p>
<h3 id="6-阀值分割"><a href="#6-阀值分割" class="headerlink" title="6.阀值分割"></a>6.阀值分割</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>固定阈值分割很直接，一句话说就是像素点值大于阈值变成一类值，小于阈值变成另一类值。</p>
<p><img src="/2020/09/15/OpenCV/4.jpg" srcset="/img/loading.gif" lazyload>http</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">&#x27;gradient.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 阈值分割</span><br>ret, th = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv2.imshow(<span class="hljs-string">&#x27;thresh&#x27;</span>, th)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p>
<ul>
<li>参数1：要处理的原图，<strong>一般是灰度图</strong></li>
<li>参数2：设定的阈值</li>
<li>参数3：对于<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code>阈值方法所选用的最大阈值，一般为255</li>
<li>参数4：阈值的方式，主要有5种，详情：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576">ThresholdTypes</a></li>
</ul>
<p>下面结合代码理解下这5种阈值方式：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 应用5种不同的阈值方法</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, th2 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, th3 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, th4 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, th5 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">&#x27;Original&#x27;</span>, <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-string">&#x27;BINARY_INV&#x27;</span>, <span class="hljs-string">&#x27;TRUNC&#x27;</span>, <span class="hljs-string">&#x27;TOZERO&#x27;</span>, <span class="hljs-string">&#x27;TOZERO_INV&#x27;</span>]<br>images = [img, th1, th2, th3, th4, th5]<br><br><span class="hljs-comment"># 使用Matplotlib显示</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i], <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 隐藏坐标轴</span><br><br>plt.show()<br></code></pre></div></td></tr></table></figure>

<p><img src="/2020/09/15/OpenCV/5.jpg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>经验之谈：很多人误以为阈值分割就是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E5%80%BC%E5%8C%96">二值化</a>。从上图中可以发现，两者并不等同，阈值分割结果是两类值，而不是两个值，所以教程开头我把二值化加了引号。</p>
</blockquote>
<p><img src="/2020/09/15/OpenCV/6.jpg" srcset="/img/loading.gif" lazyload></p>
<p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<em>它并不适用于明暗分布不均的图片</em>。 <code>cv2.adaptiveThreshold()</code>自适应阈值<strong>会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同</strong>。它有5个参数，其实很好理解，先看下效果：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 自适应阈值对比固定阈值</span><br>img = cv2.imread(<span class="hljs-string">&#x27;sudoku.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><span class="hljs-comment"># 自适应阈值</span><br>th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br>th3 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="hljs-number">17</span>, <span class="hljs-number">6</span>)<br><br>titles = [<span class="hljs-string">&#x27;Original&#x27;</span>, <span class="hljs-string">&#x27;Global(v = 127)&#x27;</span>, <span class="hljs-string">&#x27;Adaptive Mean&#x27;</span>, <span class="hljs-string">&#x27;Adaptive Gaussian&#x27;</span>]<br>images = [img, th1, th2, th3]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></div></td></tr></table></figure>

<p><img src="/2020/09/15/OpenCV/7.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>参数1：要处理的原图</li>
<li>参数2：最大阈值，一般为255</li>
<li>参数3：小区域阈值的计算方式<ul>
<li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li>
<li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li>
</ul>
</li>
<li>参数4：阈值方法，只能使用<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code>，具体见前面所讲的阈值方法</li>
<li>参数5：小区域的面积，如11就是11*11的小块</li>
<li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li>
</ul>
<h3 id="7-图像的变换"><a href="#7-图像的变换" class="headerlink" title="7.图像的变换"></a>7.图像的变换</h3><p>图像的几何变换从原理上看主要包括两种：基于2×3矩阵的仿射变换（平移、缩放、旋转和翻转等）、基于3×3矩阵的透视变换</p>
<p><img src="/2020/09/15/OpenCV/8.jpg" srcset="/img/loading.gif" lazyload></p>
<p><strong>非共线的三个对应点便可确定唯一的一个仿射变换</strong>，线性变换4个自由度+平移2个自由度→<strong>仿射变换自由度为6</strong>。、</p>
<h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>来看下OpenCV中如何实现仿射变换：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;drawing.jpg&#x27;</span>)<br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 变换前的三个点</span><br>pts1 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">210</span>, <span class="hljs-number">210</span>]])<br><span class="hljs-comment"># 变换后的三个点</span><br>pts2 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">100</span>, <span class="hljs-number">250</span>]])<br><br><span class="hljs-comment"># 生成变换矩阵</span><br>M = cv2.getAffineTransform(pts1, pts2)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img), plt.title(<span class="hljs-string">&#x27;input&#x27;</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst), plt.title(<span class="hljs-string">&#x27;output&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure>

<p>三个点已经在图中标记了出来。用<code>cv2.getAffineTransform()</code>生成变换矩阵，接下来再用<code>cv2.warpAffine()</code>实现变换。</p>
<p><img src="/2020/09/15/OpenCV/9.jpg" srcset="/img/loading.gif" lazyload></p>
<table>
<thead>
<tr>
<th>变换</th>
<th>矩阵</th>
<th>自由度</th>
<th>保持性质</th>
</tr>
</thead>
<tbody><tr>
<td>平移</td>
<td>[I, t]（2×3）</td>
<td>2</td>
<td>方向/长度/夹角/平行性/直线性</td>
</tr>
<tr>
<td>刚体</td>
<td>[R, t]（2×3）</td>
<td>3</td>
<td>长度/夹角/平行性/直线性</td>
</tr>
<tr>
<td>相似</td>
<td>[sR, t]（2×3）</td>
<td>4</td>
<td>夹角/平行性/直线性</td>
</tr>
<tr>
<td>仿射</td>
<td>[T]（2×3）</td>
<td>6</td>
<td>平行性/直线性</td>
</tr>
<tr>
<td>透视</td>
<td>[T]（3×3）</td>
<td>8</td>
<td>直线性</td>
</tr>
</tbody></table>
<h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><p>前面仿射变换后依然是平行四边形，并不能做到任意的变换。</p>
<p><img src="/2020/09/15/OpenCV/10.jpg" srcset="/img/loading.gif" lazyload></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2">透视变换</a>（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维→三维→二维的一个过程。</p>
<p>透视变换相比仿射变换更加灵活，变换后会产生一个新的四边形，但不一定是平行四边形，所以需要<strong>非共线的四个点才能唯一确定</strong>，原图中的直线变换后依然是直线。因为四边形包括了所有的平行四边形，所以透视变换包括了所有的仿射变换。</p>
<p>OpenCV中首先根据变换前后的四个点用<code>cv2.getPerspectiveTransform()</code>生成3×3的变换矩阵，然后再用<code>cv2.warpPerspective()</code>进行透视变换。实战演练一下：</p>
<p><img src="/2020/09/15/OpenCV/11.jpg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;card.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 原图中卡片的四个角点</span><br>pts1 = np.float32([[<span class="hljs-number">148</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">437</span>, <span class="hljs-number">114</span>], [<span class="hljs-number">94</span>, <span class="hljs-number">247</span>], [<span class="hljs-number">423</span>, <span class="hljs-number">288</span>]])<br><span class="hljs-comment"># 变换后分别在左上、右上、左下、右下四个点</span><br>pts2 = np.float32([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">178</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">178</span>]])<br><br><span class="hljs-comment"># 生成透视变换矩阵</span><br>M = cv2.getPerspectiveTransform(pts1, pts2)<br><span class="hljs-comment"># 进行透视变换，参数3是目标图像大小</span><br>dst = cv2.warpPerspective(img, M, (<span class="hljs-number">320</span>, <span class="hljs-number">178</span>))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img[:, :, ::-<span class="hljs-number">1</span>]), plt.title(<span class="hljs-string">&#x27;input&#x27;</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst[:, :, ::-<span class="hljs-number">1</span>]), plt.title(<span class="hljs-string">&#x27;output&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure>



<p>缩放就是调整图片的大小，使用<code>cv2.resize()</code>函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">&#x27;drawing.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 按照指定的宽度、高度缩放图片</span><br>res = cv2.resize(img, (<span class="hljs-number">132</span>, <span class="hljs-number">150</span>))<br><span class="hljs-comment"># 按照比例缩放，如x,y轴均放大一倍</span><br>res2 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">2</span>, fy=<span class="hljs-number">2</span>, interpolation=cv2.INTER_LINEAR)<br><br>cv2.imshow(<span class="hljs-string">&#x27;shrink&#x27;</span>, res), cv2.imshow(<span class="hljs-string">&#x27;zoom&#x27;</span>, res2)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p>我们也可以指定缩放方法<code>interpolation</code>，更专业点叫插值方法，默认是<code>INTER_LINEAR</code></p>
<p>镜像翻转图片，可以用<code>cv2.flip()</code>函数：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">dst</span> = cv<span class="hljs-number">2</span>.flip(img, <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>

<p>其中，参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</p>
<p><img src="/2020/09/15/OpenCV/12.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="-2"><a href="#-2" class="headerlink" title></a></h4><p>要平移图片，我们需要定义下面这样一个矩阵，tx,ty是向x和y方向平移的距离：</p>
<p>M=[10tx01ty] M = \left[ </p>
<p>  \right] M=[10tx01ty]</p>
<p>平移是用仿射变换函数<code>cv2.warpAffine()</code>实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 平移图片</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 定义平移矩阵，需要是numpy的float32类型</span><br><span class="hljs-comment"># x轴平移100，y轴平移50</span><br>M = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>]])<br><span class="hljs-comment"># 用仿射变换实现平移</span><br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">&#x27;shift&#x27;</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<h4 id="-3"><a href="#-3" class="headerlink" title></a><img src="/2020/09/15/OpenCV/13.jpg" srcset="/img/loading.gif" lazyload></h4><p>旋转同平移一样，也是用仿射变换实现的，因此也需要定义一个变换矩阵。OpenCV直接提供了 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p>
<ul>
<li>参数1：图片的旋转中心</li>
<li>参数2：旋转角度(正：逆时针，负：顺时针)</li>
<li>参数3：缩放比例，0.5表示缩小一半</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 45°旋转图片并缩小一半</span><br><span class="hljs-attribute">M</span> = cv<span class="hljs-number">2</span>.getRotationMatrix<span class="hljs-number">2</span>D((cols / <span class="hljs-number">2</span>, rows / <span class="hljs-number">2</span>), <span class="hljs-number">45</span>, <span class="hljs-number">0</span>.<span class="hljs-number">5</span>)<br><span class="hljs-attribute">dst</span> = cv<span class="hljs-number">2</span>.warpAffine(img, M, (cols, rows))<br><br><span class="hljs-attribute">cv2</span>.imshow(&#x27;rotation&#x27;, dst)<br><span class="hljs-attribute">cv2</span>.waitKey(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p><img src="/2020/09/15/OpenCV/14.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="8-代码性能优化的方法"><a href="#8-代码性能优化的方法" class="headerlink" title="8.代码性能优化的方法"></a>8.代码性能优化的方法</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> cv<span class="hljs-number">2</span><br><br><span class="hljs-attribute">start</span> = cv<span class="hljs-number">2</span>.getTickCount()<br><span class="hljs-comment"># 这里写测试代码...</span><br><span class="hljs-attribute">end</span> = cv<span class="hljs-number">2</span>.getTickCount()<br><span class="hljs-attribute">print</span>((end - start) / cv<span class="hljs-number">2</span>.getTickFrequency())<br></code></pre></div></td></tr></table></figure>

<p>这段代码就是用来测量程序运行时间的（单位：s），其中<code>cv2.getTickCount()</code>函数得到电脑启动以来的时钟周期数，<code>cv2.getTickFrequency()</code>返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用Python中的time模块计时：</p>
<figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">import <span class="hljs-built_in">time</span><br><br>start = <span class="hljs-built_in">time</span>.<span class="hljs-built_in">clock</span>()<br># 这里写测试代码...<br><span class="hljs-keyword">end</span> = <span class="hljs-built_in">time</span>.<span class="hljs-built_in">clock</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">end</span> - start)<br></code></pre></div></td></tr></table></figure>

<h4 id="-4"><a href="#-4" class="headerlink" title></a></h4><ul>
<li>数据元素少时用Python语法，数据元素多时用Numpy：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = <span class="hljs-number">10</span><br><span class="hljs-attribute">z</span> = np.uint<span class="hljs-number">8</span>([<span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># 尝试比较下面三句话各自的运行时间</span><br><span class="hljs-attribute">y</span> = x * x * x   # (<span class="hljs-number">1</span>.<span class="hljs-number">6410249677846285</span>e-<span class="hljs-number">06</span>)<br><span class="hljs-attribute">y</span> = x**<span class="hljs-number">3</span>        # (<span class="hljs-number">2</span>.<span class="hljs-number">461537451676943</span>e-<span class="hljs-number">06</span>)<br><span class="hljs-attribute">y</span> = z * z * z   # 最慢 (<span class="hljs-number">3</span>.<span class="hljs-number">1179474387907945</span>e-<span class="hljs-number">05</span>)<br></code></pre></div></td></tr></table></figure>

<p>所以Numpy的运行速度并不一定比Python本身语法快，元素数量较少时，请用Python本身格式。</p>
<ul>
<li>尽量避免使用循环，尤其嵌套循环，因为极其慢！！！</li>
<li>优先使用OpenCV/Numpy中封装好的函数</li>
<li>尽量将数据向量化，变成Numpy的数据格式</li>
<li>尽量避免数组的复制操作</li>
</ul>
<h3 id="9-无损保存和Matplotlib"><a href="#9-无损保存和Matplotlib" class="headerlink" title="9.无损保存和Matplotlib"></a>9.无损保存和Matplotlib</h3><h4 id="-5"><a href="#-5" class="headerlink" title></a></h4><ul>
<li>bmp<ul>
<li>全称：Bitmap</li>
<li><strong>不压缩</strong></li>
</ul>
</li>
<li>jpg<ul>
<li>全称：Joint Photographic Experts Group</li>
<li><strong>有损压缩方式</strong></li>
</ul>
</li>
<li>png<ul>
<li>全称：Portable Network Graphics</li>
<li><strong>无损压缩方式</strong></li>
</ul>
</li>
</ul>
<h4 id="-6"><a href="#-6" class="headerlink" title></a></h4><p>用<code>cv2.imwrite()</code>保存图片时，可以传入第三个参数（请参考<a target="_blank" rel="noopener" href="http://codec.wang/#/">接口文档</a>），用于控制保存质量：</p>
<ul>
<li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg质量控制，取值0~100，值越大，质量越好，默认为95</li>
<li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png质量控制，取值0~9，值越大，压缩比越高，默认为1</li>
</ul>
<p>还有诸如<code>CV_IMWRITE_WEBP_QUALITY</code>的参量，不常用，请参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac">ImwriteFlags</a>。</p>
<p>举例来说，原图lena.jpg的分辨率是350×350，大小49.7KB。我们把它转成不同格式看下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">new</span><span class="hljs-type">_img</span> = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br><br><span class="hljs-meta"># bmp</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_bmp.bmp&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>) <span class="hljs-meta"># 文件大小：359KB</span><br><br><span class="hljs-meta"># jpg 默认95%质量</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_jpg95.jpg&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>) <span class="hljs-meta"># 文件大小：52.3KB</span><br><span class="hljs-meta"># jpg 20%质量</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_jpg20.jpg&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>,[int(cv2.IMWRITE_JPEG_QUALITY),<span class="hljs-number">20</span>]) <span class="hljs-meta"># 文件大小：8.01KB</span><br><span class="hljs-meta"># jpg 100%质量</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_jpg100.jpg&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>,[int(cv2.IMWRITE_JPEG_QUALITY),<span class="hljs-number">100</span>]) <span class="hljs-meta"># 文件大小：82.5KB</span><br><br><span class="hljs-meta"># png 默认1压缩比</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_png1.png&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>) <span class="hljs-meta"># 文件大小：240KB</span><br><span class="hljs-meta"># png 9压缩比</span><br>cv2.imwrite(<span class="hljs-string">&#x27;img_png9.png&#x27;</span>,<span class="hljs-keyword">new</span><span class="hljs-type">_img</span>,[int(cv2.IMWRITE_PNG_COMPRESSION),<span class="hljs-number">9</span>]) <span class="hljs-meta"># 文件大小：207KB</span><br></code></pre></div></td></tr></table></figure>

<p>可以看到：</p>
<ul>
<li>bmp文件是最大的，没有任何压缩（1个像素点1byte，3通道的彩色图总大小：350×350×3/1024 ≈ 359 KB）</li>
<li>jpg/png本身就有压缩的，所以就算是100%的质量保存，体积也比bmp小很多</li>
<li>jpg的容量优势很明显，这也是它为什么如此流行的原因</li>
</ul>
<p>这里需要明确的是保存新格式时，<strong>容量大小跟原图的容量没有直接关系，而是取决于原图的分辨率大小和原图本身的内容（压缩方式）</strong>，所以lena.jpg保存成不压缩的bmp格式时，容量大小就是固定的350×350×3/1024 ≈ 359 KB；另外，容量变大不代表画质提升</p>
<h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br># 灰度图显示，cmap(color map)设置为gray<br>plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure>

<p>结果如下：</p>
<h4 id="-8"><a href="#-8" class="headerlink" title></a><img src="/2020/09/15/OpenCV/15.jpg" srcset="/img/loading.gif" lazyload></h4><p><strong>OpenCV中的图像是以BGR的通道顺序存储的</strong>，<strong>但Matplotlib是以RGB模式显示的，所以直接在Matplotlib中显示OpenCV图像会出现问题，因此需要转换一下:</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">import cv<span class="hljs-number">2</span><br>import matplotlib.pyplot as plt<br><br>img = cv<span class="hljs-number">2.</span>imread<span class="hljs-comment">(&#x27;lena.jpg&#x27;)</span><br>im<span class="hljs-name">g2</span> = img[:, :, ::<span class="hljs-number">-1</span>]<br><span class="hljs-attr"># 或使用</span><br><span class="hljs-attr"># img2</span> = cv<span class="hljs-number">2.</span>cvtColor<span class="hljs-comment">(img, cv2.COLOR_BGR2RGB)</span><br><br><span class="hljs-attr"># 显示不正确的图</span><br><span class="hljs-attr">plt.subplot(121</span>),plt.imshow<span class="hljs-comment">(img)</span> <br><br><span class="hljs-attr"># 显示正确的图</span><br><span class="hljs-attr">plt.subplot(122</span>)<br>plt.xticks<span class="hljs-comment">([])</span>, plt.yticks<span class="hljs-comment">([])</span> <span class="hljs-attr"># 隐藏x和y轴</span><br><span class="hljs-attr">plt.imshow(img2</span>)<br><br>plt.show<span class="hljs-comment">()</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><code>img[:,:,0]</code>表示图片的蓝色通道，<code>img[:,:,::-1]</code>就表示BGR翻转，变成RGB，说明一下：</p>
</blockquote>
<p>对一个字符串s翻转可以这样写：<code>s[::-1]</code>，’abc’变成’cba’，-1表示逆序。图片是二维的，所以完整地复制一副图像就是：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img2</span> = img[:,:] # 写全就是：img<span class="hljs-number">2</span> = img[<span class="hljs-number">0</span>:height,<span class="hljs-number">0</span>:width]<br></code></pre></div></td></tr></table></figure>

<p>而图片是有三个通道，相当于一个长度为3的字符串，所以通道翻转与图片复制组合起来便是<code>img[:,:,::-1]</code>。</p>
<p>结果如下：</p>
<p><img src="/2020/09/15/OpenCV/16.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="-9"><a href="#-9" class="headerlink" title></a></h4><p>不使用OpenCV，Matplotlib也可以加载和保存图片：</p>
<figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> matplotlib.image <span class="hljs-keyword">as</span> pli<br><br>img = pli.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br>plt.imshow(img)<br><br># 保存图片，需放在<span class="hljs-keyword">show</span>()函数之前<br>plt.savefig(<span class="hljs-string">&#x27;lena2.jpg&#x27;</span>)<br>plt.<span class="hljs-keyword">show</span>()<br></code></pre></div></td></tr></table></figure>

<h3 id="10-图像混合"><a href="#10-图像混合" class="headerlink" title="10.图像混合"></a>10.图像混合</h3><h4 id="-10"><a href="#-10" class="headerlink" title></a></h4><p>要叠加两张图片，可以用<code>cv2.add()</code>函数，相加两幅图片的形状（高度/宽度/通道数）必须相同。numpy中可以直接用res = img + img1相加，但这两者的结果并不相同：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = np.uint<span class="hljs-number">8</span>([<span class="hljs-number">250</span>])<br><span class="hljs-attribute">y</span> = np.uint<span class="hljs-number">8</span>([<span class="hljs-number">10</span>])<br><span class="hljs-attribute">print</span>(cv<span class="hljs-number">2</span>.add(x, y))  # <span class="hljs-number">250</span>+<span class="hljs-number">10</span> = <span class="hljs-number">260</span> =&gt; <span class="hljs-number">255</span><br><span class="hljs-attribute">print</span>(x + y)  # <span class="hljs-number">250</span>+<span class="hljs-number">10</span> = <span class="hljs-number">260</span> % <span class="hljs-number">256</span> = <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure>

<p>如果是二值化图片（只有0和255两种值），两者结果是一样的（用numpy的方式更简便一些）。</p>
<h4 id="-11"><a href="#-11" class="headerlink" title></a></h4><p>图像混合<code>cv2.addWeighted()</code>也是一种图片相加的操作，只不过两幅图片的权重不一样，γ相当于一个修正值：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img1</span> = cv<span class="hljs-number">2</span>.imread(&#x27;lena_small.jpg&#x27;)img<span class="hljs-number">2</span> = cv<span class="hljs-number">2</span>.imread(&#x27;opencv-logo-white.png&#x27;)res = cv<span class="hljs-number">2</span>.addWeighted(img<span class="hljs-number">1</span>, <span class="hljs-number">0</span>.<span class="hljs-number">6</span>, img<span class="hljs-number">2</span>, <span class="hljs-number">0</span>.<span class="hljs-number">4</span>, <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p><img src="/2020/09/15/OpenCV/17.jpg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>经验之谈：α和β都等于1时，就相当于图片相加。</p>
</blockquote>
<h4 id="-12"><a href="#-12" class="headerlink" title></a></h4><p>按位操作包括按位与/或/非/异或操作，有什么用途呢？比如说我们要实现下图的效果：</p>
<p><img src="/2020/09/15/OpenCV/18.jpg" srcset="/img/loading.gif" lazyload></p>
<p>如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作。首先来了解一下<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A9%E8%86%9C/8544392?fr=aladdin">掩膜</a>（mask）的概念：掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡，看下图就一目了然了：</p>
<p><img src="/2020/09/15/OpenCV/19.jpg" srcset="/img/loading.gif" lazyload></p>
<p>所以我们的思路就是把原图中要放logo的区域抠出来，再把logo放进去就行了：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img1</span> = cv<span class="hljs-number">2</span>.imread(&#x27;lena.jpg&#x27;)<br><span class="hljs-attribute">img2</span> = cv<span class="hljs-number">2</span>.imread(&#x27;opencv-logo-white.png&#x27;)<br><br><span class="hljs-comment"># 把logo放在左上角，所以我们只关心这一块区域</span><br><span class="hljs-attribute">rows</span>, cols = img<span class="hljs-number">2</span>.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-attribute">roi</span> = img<span class="hljs-number">1</span>[:rows, :cols]<br><br><span class="hljs-comment"># 创建掩膜</span><br><span class="hljs-attribute">img2gray</span> = cv<span class="hljs-number">2</span>.cvtColor(img<span class="hljs-number">2</span>, cv<span class="hljs-number">2</span>.COLOR_BGR<span class="hljs-number">2</span>GRAY)<br><span class="hljs-attribute">ret</span>, mask = cv<span class="hljs-number">2</span>.threshold(img<span class="hljs-number">2</span>gray, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, cv<span class="hljs-number">2</span>.THRESH_BINARY)<br><span class="hljs-attribute">mask_inv</span> = cv<span class="hljs-number">2</span>.bitwise_not(mask)<br><br><span class="hljs-comment"># 保留除logo外的背景</span><br><span class="hljs-attribute">img1_bg</span> = cv<span class="hljs-number">2</span>.bitwise_and(roi, roi, mask=mask_inv)<br><span class="hljs-attribute">dst</span> = cv<span class="hljs-number">2</span>.add(img<span class="hljs-number">1</span>_bg, img<span class="hljs-number">2</span>)  # 进行融合<br><span class="hljs-attribute">img1</span>[:rows, :cols] = dst  # 融合后放在原图上<br></code></pre></div></td></tr></table></figure>

<h3 id="11-平滑图像"><a href="#11-平滑图像" class="headerlink" title="11.平滑图像"></a>11.平滑图像</h3><h4 id="-13"><a href="#-13" class="headerlink" title></a></h4><p>关于滤波和模糊</p>
<ul>
<li>它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言）</li>
<li>低通滤波器是模糊，高通滤波器是锐化</li>
</ul>
<p>低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，<strong>所以低通滤波器用于去除噪点、平滑和模糊图像</strong>。<strong>高通滤波器则反之，用来增强图像边缘，进行锐化处理。</strong></p>
<blockquote>
<p>常见噪声有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958?fr=aladdin">椒盐噪声</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p>
</blockquote>
<h4 id="-14"><a href="#-14" class="headerlink" title></a></h4><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p>
<p>kernel=19[111111111] kernel = \frac{1}{9}\left[ </p>
<p>  \right] kernel=91[111111111]</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">img</span> = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>)<br><span class="hljs-attr">blur</span> = cv2.blur(img, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 均值模糊</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>所有的滤波函数都有一个可选参数borderType，这个参数就是<a target="_blank" rel="noopener" href="http://codec.wang/#/Extra-08-Padding-and-Convolution/">番外篇：卷积基础(图片边框)</a>中所说的边框填充方式。</p>
</blockquote>
<h4 id="-15"><a href="#-15" class="headerlink" title></a></h4><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p>
<p>k=a[111111111] k = a\left[ </p>
<p>  \right] k=a[111111111]</p>
<p>用<code>cv2.boxFilter()</code>函数实现，当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1/9；normalize为False的时候，a=1，相当于求区域内的像素和。</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span><br><span class="hljs-attribute">blur</span> = cv<span class="hljs-number">2</span>.boxFilter(img, -<span class="hljs-number">1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), normalize=True)<br></code></pre></div></td></tr></table></figure>

<h4 id="-16"><a href="#-16" class="headerlink" title></a></h4><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，来，数学时间( ╯□╰ )，还记得标准正态分布的曲线吗？</p>
<p><img src="/2020/09/15/OpenCV/20.jpg" srcset="/img/loading.gif" lazyload></p>
<p>显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gaussian_filter">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的<a target="_blank" rel="noopener" href="http://codec.wang/#/">番外小篇</a>）：</p>
<p>k=[0.06250.1250.06250.1250.250.1250.06250.1250.0625] k = \left[ </p>
<p>  \right] k=[0.06250.1250.06250.1250.250.1250.06250.1250.0625]</p>
<p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">img</span> = cv2.imread(<span class="hljs-string">&#x27;gaussian_noise.bmp&#x27;</span>)<br><span class="hljs-comment"># 均值滤波vs高斯滤波</span><br><span class="hljs-attr">blur</span> = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br><span class="hljs-attr">gaussian</span> = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">1</span>)  <span class="hljs-comment"># 高斯滤波</span><br></code></pre></div></td></tr></table></figure>

<p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p>
<p><img src="/2020/09/15/OpenCV/21.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="-17"><a href="#-17" class="headerlink" title></a></h4><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E5%80%BC">中值</a>又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，适用于去除椒盐噪声和斑点噪声。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p>
<p>比如下面这张斑点噪声图，用中值滤波显然更好：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">img</span> = cv2.imread(<span class="hljs-string">&#x27;salt_noise.bmp&#x27;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 均值滤波vs中值滤波</span><br><span class="hljs-attr">blur</span> = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br><span class="hljs-attr">median</span> = cv2.medianBlur(img, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 中值滤波</span><br></code></pre></div></td></tr></table></figure>

<h4 id="-18"><a href="#-18" class="headerlink" title></a><img src="/2020/09/15/OpenCV/22.jpg" srcset="/img/loading.gif" lazyload></h4><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2">双边滤波</a>。用<code>cv2.bilateralFilter()</code>函数实现：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">img</span> = cv<span class="hljs-number">2</span>.imread(&#x27;lena.jpg&#x27;)<br><span class="hljs-comment"># 双边滤波vs高斯滤波</span><br><span class="hljs-attribute">gau</span> = cv<span class="hljs-number">2</span>.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)  # 高斯滤波<br><span class="hljs-attribute">blur</span> = cv<span class="hljs-number">2</span>.bilateralFilter(img, <span class="hljs-number">9</span>, <span class="hljs-number">75</span>, <span class="hljs-number">75</span>)  # 双边滤波<br></code></pre></div></td></tr></table></figure>

<p><img src="/2020/09/15/OpenCV/23.jpg" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，双边滤波明显保留了更多边缘信息。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5/">指令速查</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/OpenCV/">OpenCV</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/17/%E5%B7%A5%E5%85%B7%E4%BB%AC/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">工具们</span>
                        <span class="visible-mobile">Pre</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"NqfCe9N1ldsKnFmEvujkDdSk-MdYXbMMI","appKey":"B34Gii3HEWEBa3njgz1wmchx","path":"window.location.pathname","placeholder":"来说哈子","avatar":"retro","meta":["nick"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Toc</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://wtling.github.io" target="_blank" rel="nofollow noopener"><span>哈哈哈</span></a> <i class="iconfont icon-love"></i> <a href="https://wtling.github.io" target="_blank" rel="nofollow noopener"><span>哈哈哈</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d311059c1b774ee7657bb02e7ecfd0fb";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
